Index: addon/components/models-table.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {assign} from '@ember/polyfills';\nimport {on} from '@ember/object/evented';\nimport {typeOf, compare, isBlank, isNone} from '@ember/utils';\nimport {run} from '@ember/runloop';\nimport Component from '@ember/component';\nimport {assert, warn} from '@ember/debug';\nimport O, {\n  observer,\n  computed,\n  getProperties,\n  setProperties,\n  getWithDefault,\n  set,\n  get\n} from '@ember/object';\nimport {capitalize, dasherize} from '@ember/string';\nimport jQ from 'jquery';\nimport {isArray, A} from '@ember/array';\nimport betterCompare from '../utils/better-compare';\n\nimport DefaultTheme from '../themes/default';\nimport BootstrapTheme from '../themes/bootstrap';\n\nimport layout from '../templates/components/models-table';\nimport ModelsTableColumn from '../utils/column';\n\n/**\n * @typedef {object} groupedHeader\n * @property {string} title header for grouped columns\n * @property {number} colspan HTML colspan attr\n * @property {number} rowspan HTML rowspan attr\n */\n\nconst {\n  keys\n} = Object;\n\nconst NOT_SORTED = -1;\n\nconst defaultMessages = {\n  searchLabel: 'Search:',\n  searchPlaceholder: '',\n  'columns-title': 'Columns',\n  'columns-showAll': 'Show All',\n  'columns-hideAll': 'Hide All',\n  'columns-restoreDefaults': 'Restore Defaults',\n  tableSummary: 'Show %@ - %@ of %@',\n  allColumnsAreHidden: 'All columns are hidden. Use <strong>columns</strong>-dropdown to show some of them',\n  noDataToShow: 'No records to show'\n};\n\n/**\n * @ignore\n * @param {ModelsTableColumn} column\n * @returns {boolean}\n */\nfunction isSortedByDefault(column) {\n  return column.sortPrecedence > NOT_SORTED;\n}\n\n/**\n * Default filter-function used in the filter by columns\n *\n * @param {string} cellValue value in the table cell\n * @param {string} filterString needed substring\n * @returns {boolean}\n * @ignore\n */\nfunction defaultFilter(cellValue, filterString) {\n  return -1 !== cellValue.indexOf(filterString);\n}\n\n/**\n * Convert some string to the human readable one\n *\n * @param {string} name value to convert\n * @returns {string}\n * @ignore\n */\nfunction propertyNameToTitle(name) {\n  return capitalize(dasherize(name).replace(/-/g, ' '));\n}\n\n/**\n * @ignore\n * @param {string} option\n * @returns {{value: *, label: *}}\n */\nfunction optionStrToObj(option) {\n  return {value: option, label: option};\n}\n\n/**\n * Updates <code>filterOptions</code> for column which use <code>filterWithSelect</code>\n * and don't have <code>predefinedFilterOptions</code>\n * <code>filterOptions</code> are calculated like <code>data.mapBy(column.propertyName).uniq()</code>,\n * where data is component's <code>data</code>\n *\n * @param {string} propertyName\n * @returns {object[]}\n * @ignore\n */\nfunction getFilterOptionsCP(propertyName) {\n  return computed(`data.@each.${propertyName}`, function () {\n    let data = get(this, 'data');\n    let predefinedFilterOptions = get(this, 'predefinedFilterOptions');\n    let filterWithSelect = get(this, 'filterWithSelect');\n    if (filterWithSelect && 'array' !== typeOf(predefinedFilterOptions)) {\n      let _data = A(A(data).compact());\n      let options = A(_data.mapBy(propertyName)).compact();\n      if (get(this, 'sortFilterOptions')) {\n        options = options.sort();\n      }\n      return A(['', ...options]).uniq().map(optionStrToObj);\n    }\n    return [];\n  });\n}\n\n/**\n * @ignore\n * @param {number} count\n * @returns {number[]}\n */\nfunction generateIndexes(count) {\n  let ret = new Array(count);\n  for (let i = 0; i < count; i++) {\n    ret.push(i);\n  }\n  return ret;\n}\n\n/**\n * Table-component with pagination, sorting and filtering.\n *\n * It should be used when whole dataset is already loaded. For server-side pagination, filtering and sorting\n * [models-table-server-paginated](Components.ModelsTableServerPaginated.html) should be used.\n *\n * Basic usage example:\n *\n * ```hbs\n * {{models-table data=model columns=columns}}\n * ```\n *\n * Usage with block context:\n *\n * ```hbs\n * {{#models-table data=data columns=columns as |mt|}}\n *   {{mt.global-filter}}\n *   {{mt.columns-dropdown}}\n *   {{mt.table}}\n *   {{mt.footer}}\n * {{/models-table}}\n * ```\n *\n * ModelsTable yields references to the following contextual components:\n *\n * * [models-table/global-filter](Components.ModelsTableGlobalFilter.html) - global filter used for table data\n * * [models-table/columns-dropdown](Components.ModelsTableColumnsDropdown.html) - dropdown with list of options to toggle columns and column-sets visibility\n * * [models-table/table](Components.ModelsTableTable.html) - table with a data\n * * [models-table/footer](Components.ModelsTableFooter.html) - summary and pagination\n *\n * Check own docs for each component to get detailed info.\n *\n * ModelsTable has a lot of options you may configure, but there are two required properties called `data` and `columns`. First one contains data (e.g. list of records from the store). Second one is a list of table's columns (check [models-table-column](Utils.ModelsTableColumn.html) for available options).\n *\n * @namespace Components\n * @class ModelsTable\n * @extends Ember.Component\n */\nexport default Component.extend({\n\n  layout,\n\n  classNames: ['models-table-wrapper'],\n\n  /**\n   * @type string\n   * @property theme\n   * @default 'bootstrap'\n   */\n  theme: 'bootstrap',\n\n  /**\n   * Number of records shown on one table-page\n   *\n   * @type number\n   * @property pageSize\n   * @default 10\n   */\n  pageSize: 10,\n\n  /**\n   * @type number\n   * @property currentPageNumber\n   * @default 1\n   */\n  currentPageNumber: 1,\n\n  /**\n   * @type string[]\n   * @property sortProperties\n   * @default []\n   */\n  sortProperties: computed(function() {\n    return A([]);\n  }),\n\n  /**\n   * Determines if multi-columns sorting should be used\n   *\n   * @type boolean\n   * @property multipleColumnsSorting\n   * @default false\n   */\n  multipleColumnsSorting: true,\n\n  /**\n   * Determines if component footer should be shown on the page\n   *\n   * @type boolean\n   * @property showComponentFooter\n   * @default true\n   */\n  showComponentFooter: true,\n\n  /**\n   * Determines if numeric pagination should be used\n   *\n   * @type boolean\n   * @property useNumericPagination\n   * @default false\n   */\n  useNumericPagination: false,\n\n  /**\n   * Determines if columns-dropdown should be shown\n   *\n   * @type boolean\n   * @property showColumnsDropdown\n   * @default true\n   */\n  showColumnsDropdown: true,\n\n  /**\n   * Determines if filtering by columns should be available to the user\n   *\n   * @type boolean\n   * @property useFilteringByColumns\n   * @default true\n   */\n  useFilteringByColumns: true,\n\n  /**\n   * @type string\n   * @property filterString\n   * @default ''\n   */\n  filterString: '',\n\n  /**\n   * Determines if filtering (global and by column) should ignore case\n   *\n   * @type boolean\n   * @property filteringIgnoreCase\n   * @default false\n   */\n  filteringIgnoreCase: false,\n\n  /**\n   * Determines if filtering should be done by hidden columns\n   *\n   * **Notice:** after changing this value filtering results will be updated only after filter options are changed\n   *\n   * @type boolean\n   * @property doFilteringByHiddenColumns\n   * @default true\n   */\n  doFilteringByHiddenColumns: true,\n\n  /**\n   * Determines if \"Global filter\"-field should be shown\n   *\n   * @type boolean\n   * @property showGlobalFilter\n   * @default true\n   */\n  showGlobalFilter: true,\n\n  /**\n   * Determines if focus should be on the \"Global filter\"-field on component render\n   *\n   * @type boolean\n   * @property focusGlobalFilter\n   * @default false\n   */\n  focusGlobalFilter: false,\n\n  /**\n   * Determines if <code>processedColumns</code> will be updated if <code>columns</code> are changed (<code>propertyName</code> and\n   * <code>template</code> are observed)\n   * <b>IMPORTANT</b> All filter, sort and visibility options will be dropped to the default values while updating\n   *\n   * @type boolean\n   * @property columnsAreUpdateable\n   * @default false\n   */\n  columnsAreUpdateable: false,\n\n  /**\n   * <code>columns</code> fields which are observed to update shown table-columns\n   * It is used only if <code>columnsAreUpdateable</code> is <code>true</code>\n   *\n   * @type string[]\n   * @property columnFieldsToCheckUpdate\n   * @default ['propertyName', 'template']\n   */\n  columnFieldsToCheckUpdate: computed(function() {\n    return A(['propertyName', 'template']);\n  }),\n\n  /**\n   * @type Object\n   * @property themeInstance\n   */\n  themeInstance: computed('theme', function() {\n    return 'bootstrap' === get(this, 'theme') ? BootstrapTheme.create() : DefaultTheme.create();\n  }),\n\n  /**\n   * All table records\n   *\n   * @type object[]\n   * @property data\n   * @default []\n   */\n  data: computed(function() {\n    return A([]);\n  }),\n\n  /**\n   * Table columns\n   *\n   * @type object[]\n   * @property columns\n   * @default []\n   */\n  columns: computed(function() {\n    return A([]);\n  }),\n\n  /**\n   * Sets of columns that can be toggled together.\n   * Each object should have:\n   *  * `label` (string) - The label for the set. This will be displayed in the columns dropdown.\n   *  * `showColumns` (array|Function) - This should either be an array of `propertyNames` to show, or a function. If it is a function, the function will be called with the `processedColumns` as attribute.\n   *  * `hideOtherColumns` (boolean) -  If this is true (default), all columns not specified in <code>showColumns</code> will be hidden. If this is set to false, other columns will be left at whatever visibility they were before.\n   *  * `toggleSet` (boolean) - If this is true (default is false), the set columns will be shown if one of them is currently hidden,\n   else they will all be hidden. Settings this will result in a default of `hideOtherColumns=false`\n   *\n   * @type Object[]\n   * @property columnSets\n   * @default []\n   */\n  columnSets: computed(function() {\n    return A([]);\n  }),\n\n  /**\n   * @type Object[]\n   * @property processedColumns\n   * @default []\n   * @private\n   */\n  processedColumns: computed(function() {\n    return A([]);\n  }),\n\n  /**\n   * Overrides for messages used in the component.\n   *\n   * @type Object\n   * @property messages\n   * @default {}\n   */\n  messages: computed(function() {\n    return O.create({});\n  }),\n\n  /**\n   * List of the additional headers. Used to group columns.\n   *\n   * Each object may have such fields:\n   *\n   * * `title` (string) - Header for grouped column\n   * * `colspan` (number) - HTML colspan attr\n   * * `rowspan` (number) - HTML rowspan attr\n   *\n   * @property groupedHeaders\n   * @type groupedHeader[][]\n   * @default []\n   */\n  groupedHeaders: computed(function() {\n    return A([]);\n  }),\n\n  /**\n   * Determines if page size should be shown\n   *\n   * @type boolean\n   * @property showPageSize\n   * @default true\n   */\n  showPageSize: true,\n\n  /**\n   * Indexes of the expanded rows\n   * It's set to the initial value when current page or page size is changed\n   *\n   * @type number[]\n   * @property _expandedRowIndexes\n   * @private\n   */\n  _expandedRowIndexes: null,\n\n  /**\n   * true - allow to expand more than 1 row\n   * false - only 1 row may be expanded in the same time\n   *\n   * @type boolean\n   * @property multipleExpand\n   * @default false\n   */\n  multipleExpand: false,\n\n  /**\n   * @type object[]\n   * @property _selectedItems\n   * @private\n   */\n  _selectedItems: null,\n\n  /**\n   * Allow or disallow to select rows on click\n   * If `false` - no row can be selected\n   *\n   * @type boolean\n   * @property selectRowOnClick\n   * @default true\n   */\n  selectRowOnClick: true,\n\n  /**\n   * Allow or disallow to select multiple rows\n   * If `false` - only one row may be selected in the same time\n   *\n   * @type boolean\n   * @property multipleSelect\n   * @default false\n   */\n  multipleSelect: false,\n\n  /**\n   * @type string\n   * @property expandedRowComponent\n   * @default ''\n   */\n  expandedRowComponent: '',\n\n  /**\n   * Action-name sent on user interaction\n   *\n   * @type string\n   * @property displayDataChangedAction\n   * @default 'displayDataChanged'\n   */\n  displayDataChangedAction: 'displayDataChanged',\n\n  /**\n   * Determines if action on user interaction should be sent\n   *\n   * @default false\n   * @property sendDisplayDataChangedAction\n   * @type boolean\n   */\n  sendDisplayDataChangedAction: false,\n\n  /**\n   * Action-name sent on change of visible columns\n   *\n   * The action will receive an array of objects as parameter, where every object looks like this: `{ propertyName: 'firstName', isHidden: true, mayBeHidden: false }`\n   *\n   * @type string\n   * @property columnsVisibilityChangedAction\n   * @default 'columnsVisibilityChanged'\n   */\n  columnsVisibilityChangedAction: 'columnsVisibilityChanged',\n\n  /**\n   * Determines if action on change of visible columns should be sent\n   *\n   * @default false\n   * @property sendColumnsVisibilityChangedAction\n   * @type boolean\n   */\n  sendColumnsVisibilityChangedAction: false,\n\n  /**\n   * Rows with this items should be preselected on component init\n   * It's NOT a list of indexes!\n   *\n   * @default null\n   * @property preselectedItems\n   * @type object[]|null\n   */\n  preselectedItems: null,\n\n  /**\n   * List of the currently visible columns\n   *\n   * @type Object[]\n   * @property visibleProcessedColumns\n   * @default []\n   * @private\n   */\n  visibleProcessedColumns: computed.filterBy('processedColumns', 'isVisible', true),\n\n  /**\n   * True if all processedColumns are hidden by <code>isHidden</code>\n   *\n   * @type boolean\n   * @property allColumnsAreHidden\n   * @readonly\n   * @private\n   */\n  allColumnsAreHidden: computed('processedColumns.@each.isHidden', function () {\n    const processedColumns = get(this, 'processedColumns');\n    return processedColumns.length > 0 && processedColumns.isEvery('isHidden', true);\n  }),\n\n  /**\n   * @type boolean\n   * @property globalFilterUsed\n   * @readonly\n   * @private\n   */\n  globalFilterUsed: computed.notEmpty('filterString'),\n\n  /**\n   * Global filter or filter by any column is used\n   *\n   * @type boolean\n   * @property anyFilterUsed\n   * @readonly\n   * @private\n   */\n  anyFilterUsed: computed('globalFilterUsed', 'processedColumns.@each.filterUsed', function () {\n    return get(this, 'globalFilterUsed') || get(this, 'processedColumns').isAny('filterUsed');\n  }),\n\n  /**\n   * True if all processedColumns don't use filtering and sorting\n   *\n   * @type boolean\n   * @property noHeaderFilteringAndSorting\n   * @readonly\n   * @private\n   */\n  noHeaderFilteringAndSorting: computed('processedColumns.@each.{useSorting,useFilter}', function () {\n    const processedColumns = get(this, 'processedColumns');\n    return processedColumns.isEvery('useFilter', false) && processedColumns.isEvery('useSorting', false);\n  }),\n\n  /**\n   * Number of pages\n   *\n   * @type number\n   * @property pagesCount\n   * @readonly\n   * @private\n   */\n  pagesCount: computed('arrangedContent.[]', 'pageSize', function () {\n    const pagesCount = get(this, 'arrangedContent.length') / parseInt(get(this, 'pageSize'), 10);\n    return (0 === pagesCount % 1) ? pagesCount : (Math.floor(pagesCount) + 1);\n  }),\n\n  /**\n   * @type Object[]\n   * @property filteredContent\n   * @readonly\n   * @private\n   */\n  filteredContent: computed('filterString', 'data.[]', 'useFilteringByColumns', 'processedColumns.@each.filterString', function () {\n    const {\n      processedColumns,\n      data,\n      useFilteringByColumns,\n      filteringIgnoreCase,\n      doFilteringByHiddenColumns\n    } = getProperties(this, 'processedColumns', 'data', 'useFilteringByColumns', 'filteringIgnoreCase', 'doFilteringByHiddenColumns');\n    let filterString = get(this, 'filterString');\n\n    if (!data) {\n      return A([]);\n    }\n\n    let _processedColumns = processedColumns;\n    if (!doFilteringByHiddenColumns) {\n      _processedColumns = A(_processedColumns.filterBy('isHidden', false));\n    }\n\n    // global search\n    let globalSearch = data.filter(function (row) {\n      return _processedColumns.length ? _processedColumns.any(c => {\n        const filterFor = get(c, 'filteredBy') || get(c, 'propertyName');\n        if (filterFor) {\n          let cellValue = '' + get(row, filterFor);\n          if (filteringIgnoreCase) {\n            cellValue = cellValue.toLowerCase();\n            filterString = filterString.toLowerCase();\n          }\n          return -1 !== cellValue.indexOf(filterString);\n        }\n        return false;\n      }) : true;\n    });\n\n    if (!useFilteringByColumns) {\n      return A(globalSearch);\n    }\n\n    // search by each column\n    return A(globalSearch.filter(row => {\n      return _processedColumns.length ? _processedColumns.every(c => {\n        const filterFor = get(c, 'filteredBy') || get(c, 'propertyName');\n        if (filterFor) {\n          let cellValue = '' + get(row, filterFor);\n          if (get(c, 'useFilter')) {\n            let filterString = get(c, 'filterString');\n            if (get(c, 'filterWithSelect') && '' === filterString) {\n              return true;\n            }\n            if (filteringIgnoreCase) {\n              cellValue = typeOf(cellValue) === 'string' ? cellValue.toLowerCase() : cellValue;\n              filterString = typeOf(filterString) === 'string' ? filterString.toLowerCase() : filterString;\n            }\n            return 'function' === typeOf(c.filterFunction) ? c.filterFunction(cellValue, filterString, row) : 0 === compare(cellValue, filterString);\n          }\n          return true;\n        }\n        return true;\n      }) : true;\n    }));\n  }),\n\n  /**\n   * @type Object[]\n   * @property arrangedContent\n   * @readonly\n   * @private\n   */\n  arrangedContent: computed('filteredContent.[]', 'sortProperties.[]', function () {\n    const filteredContent = get(this, 'filteredContent');\n    let sortProperties = get(this, 'sortProperties').map(p => {\n      let [prop, direction] = p.split(':');\n      direction = direction || 'asc';\n\n      return [prop, direction];\n    });\n\n    let _filteredContent = filteredContent.slice();\n    return sortProperties.length ? A(_filteredContent.sort((row1, row2) => {\n      for (let i = 0; i < sortProperties.length; i++) {\n        let [prop, direction] = sortProperties[i];\n        let result = betterCompare(get(row1, prop), get(row2, prop));\n        if (result !== 0) {\n          return (direction === 'desc') ? (-1 * result) : result;\n        }\n      }\n\n      return 0;\n    })) : _filteredContent;\n  }),\n\n  /**\n   * Content of the current table page\n   *\n   * @type Object[]\n   * @property visibleContent\n   * @readonly\n   * @private\n   */\n  visibleContent: computed('arrangedContent.[]', 'pageSize', 'currentPageNumber', function () {\n    let {\n      arrangedContent,\n      pageSize,\n      currentPageNumber\n    } = getProperties(this, 'arrangedContent', 'pageSize', 'currentPageNumber');\n    pageSize = parseInt(pageSize, 10);\n    const startIndex = pageSize * (currentPageNumber - 1);\n    if (get(arrangedContent, 'length') < pageSize) {\n      return arrangedContent;\n    }\n    return A(arrangedContent.slice(startIndex, startIndex + pageSize));\n  }),\n\n  /**\n   * Is user on the last page\n   *\n   * @type boolean\n   * @property isLastPage\n   * @readonly\n   * @private\n   */\n  isLastPage: computed('currentPageNumber', 'pagesCount', function () {\n    return get(this, 'currentPageNumber') >= get(this, 'pagesCount');\n  }),\n\n  /**\n   * Alias to <code>arrangedContent.length</code>\n   *\n   * @type number\n   * @property arrangedContentLength\n   * @readonly\n   * @private\n   */\n  arrangedContentLength: computed.alias('arrangedContent.length'),\n\n  /**\n   * Index of the first currently shown record\n   *\n   * @type number\n   * @property firstIndex\n   * @private\n   */\n  firstIndex: computed('arrangedContentLength' ,'pageSize', 'currentPageNumber', function () {\n    const {\n      currentPageNumber,\n      pageSize,\n      arrangedContentLength\n      } = getProperties(this, 'currentPageNumber', 'pageSize', 'arrangedContentLength');\n    return 0 === arrangedContentLength ? 0 : parseInt(pageSize, 10) * (currentPageNumber - 1) + 1;\n  }),\n\n  /**\n   * Index of the last shown record\n   *\n   * @type number\n   * @property lastIndex\n   * @readonly\n   * @private\n   */\n  lastIndex: computed('isLastPage', 'arrangedContentLength', 'currentPageNumber', 'pageSize', function () {\n    const {\n      currentPageNumber,\n      pageSize,\n      isLastPage,\n      arrangedContentLength\n      } = getProperties(this, 'currentPageNumber', 'pageSize', 'isLastPage', 'arrangedContentLength');\n    return isLastPage ? arrangedContentLength : currentPageNumber * parseInt(pageSize, 10);\n  }),\n\n  /**\n   * List of possible <code>pageSize</code> values\n   * Used to change size of <code>visibleContent</code>\n   *\n   * @type number[]\n   * @default [10, 25, 50]\n   * @property pageSizeValues\n   */\n  pageSizeValues: computed(function() {\n    return A([10, 25, 50]);\n  }),\n\n  /**\n   * List of options for pageSize-selectBox\n   * It's mapped from <code>pageSizeValues</code>\n   * This value should not be set manually!\n   *\n   * @type {value: string|number, label: string|number}\n   * @property pageSizeOptions\n   * @default []\n   * @private\n   */\n  pageSizeOptions: computed(function() {\n    return A([]);\n  }),\n\n  /**\n   * These are options for the columns dropdown.\n   * By default, the \"Show All\", 'Hide All\" and \"Restore Defaults\" buttons are displayed.\n   *\n   * @type { showAll: boolean, hideAll: boolean, restoreDefaults: boolean, columnSets: object[] }\n   * @property columnDropdownOptions\n   * @readonly\n   * @private\n   */\n  columnDropdownOptions: computed('columnSets.{label,showColumns,hideOtherColumns}', function() {\n    return O.create({\n      showAll: true,\n      hideAll: true,\n      restoreDefaults: true,\n      columnSets: A(get(this, 'columnSets') || [])\n    });\n  }),\n\n  /**\n   * Show first page if for some reasons there is no content for current page, but table data exists\n   *\n   * @method visibleContentObserver\n   * @returns {undefined}\n   * @private\n   */\n  visibleContentObserver() {\n    run.once(this, this.visibleContentObserverOnce);\n  },\n\n  /**\n   * @method visibleContentObserverOnce\n   * @returns {undefined}\n   * @private\n   */\n  visibleContentObserverOnce() {\n    let visibleContentLength = get(this, 'visibleContent.length');\n    let dataLength = get(this, 'data.length');\n    let currentPageNumber = get(this, 'currentPageNumber');\n    if (!visibleContentLength && dataLength && currentPageNumber !== 1) {\n      set(this, 'currentPageNumber', 1);\n    }\n  },\n\n  /**\n   * @method contentChangedAfterPolling\n   * @returns {undefined}\n   * @private\n   */\n  contentChangedAfterPolling () {\n    run.once(this, this.contentChangedAfterPollingOnce);\n  },\n\n  /**\n   * @method contentChangedAfterPollingOnce\n   * @returns {undefined}\n   * @private\n   */\n  contentChangedAfterPollingOnce () {\n    get(this, 'filteredContent');\n    this.notifyPropertyChange('filteredContent');\n  },\n\n  /**\n   * Component init\n   *\n   * Set visibility and filtering attributes for each column\n   * Update messages used by table with user-provided messages (@see {@link messages})\n   *\n   * @method setup\n   * @returns {undefined}\n   */\n  setup: on('init', function() {\n    this._setupSelectedRows();\n    this._setupExpandedRows();\n    this._setupColumns();\n    this._setupMessages();\n    this._setupPageSizeOptions();\n\n    if (get(this, 'columnsAreUpdateable')) {\n      let columnFieldsToCheckUpdate = get(this, 'columnFieldsToCheckUpdate');\n      assert('`columnFieldsToCheckUpdate` should be an array of strings', 'array' === typeOf(columnFieldsToCheckUpdate));\n      columnFieldsToCheckUpdate.forEach(propertyName => this.addObserver(`columns.@each.${propertyName}`, this, this._setupColumnsOnce));\n    }\n    this.addObserver('visibleContent.length', this, this.visibleContentObserver);\n  }),\n\n  /**\n   * Recalculate processedColumns when the columns attr changes\n   *\n   * @method updateColumns\n   */\n  updateColumns: on('didReceiveAttrs', function() {\n    if (get(this, 'columnsAreUpdateable')) {\n      this._setupColumns();\n    }\n  }),\n\n  /**\n   * Focus on \"Global filter\" on component render\n   *\n   * @method focus\n   */\n  focus: on('didInsertElement', function () {\n    if (get(this, 'showGlobalFilter') && get(this, 'focusGlobalFilter')) {\n      jQ('.filterString').focus();\n    }\n  }),\n\n  /**\n   * Preselect table rows if `preselectedItems` is provided\n   * `multipleSelected` may be set `true` if `preselectedItems` has more than 1 item\n   *\n   * @private _setupSelectedRows\n   * @returns {undefined}\n   * @method\n   */\n  _setupSelectedRows() {\n    set(this, '_selectedItems', A([]));\n    let preselectedItems = get(this, 'preselectedItems');\n    if (isArray(preselectedItems)) {\n      set(this, '_selectedItems', A(preselectedItems));\n      if (preselectedItems.length > 1 && !get(this, 'multipleSelected')) {\n        warn('`multipleSelected` is set `true`, because you have provided multiple `preselectedItems`.');\n        set(this, 'multipleSelected', true);\n      }\n    }\n  },\n\n  /**\n   * @method _setupExpandedRows\n   * @returns {undefined}\n   * @private\n   */\n  _setupExpandedRows() {\n    set(this, '_expandedRowIndexes', A([]));\n  },\n\n  /**\n   * Wrapper for <code>_setupColumns</code> to call it only once when observer is fired\n   *\n   * @method _setupColumnsOnce\n   * @returns {undefined}\n   * @private\n   */\n  _setupColumnsOnce() {\n    run.once(this, this._setupColumns);\n  },\n\n  /**\n   * Create a column.\n   * This can be overwritten if you need to use your own column object.\n   *\n   * @method _createColumn\n   * @param {object} options\n   * @returns {Object}\n   * @private\n   */\n  _createColumn(options) {\n    return ModelsTableColumn.create(options);\n  },\n\n  /**\n   * Create new properties for <code>columns</code> (filterString, useFilter, isVisible, defaultVisible)\n   *\n   * @method _setupColumns\n   * @returns {undefined}\n   * @private\n   */\n  _setupColumns () {\n    let self = this;\n\n    let nColumns = A(get(this, 'columns').map(column => {\n      let filterFunction = get(column, 'filterFunction');\n      filterFunction = 'function' === typeOf(filterFunction) ? filterFunction : defaultFilter;\n\n      let c = this._createColumn(column);\n      let propertyName = get(c, 'propertyName');\n      let sortedBy = get(c, 'sortedBy');\n      let filteredBy = get(c, 'filteredBy');\n      setProperties(c, {\n        data: get(this, 'data'),\n        filterString: get(c, 'filterString') || '',\n        useFilter: !isNone(filteredBy || propertyName) && !get(c, 'disableFiltering'),\n        useSorting: !isNone(sortedBy || propertyName) && !get(c, 'disableSorting'),\n        originalDefinition: column\n      });\n\n      set(c, 'filterFunction', filterFunction);\n\n      if (isNone(get(c, 'mayBeHidden'))) {\n        set(c, 'mayBeHidden', true);\n      }\n\n      const { sortDirection, sortPrecedence } = column;\n      const hasSortPrecedence = !isNone(sortPrecedence) && sortPrecedence > NOT_SORTED;\n      const defaultSortPrecedence = hasSortPrecedence ? sortPrecedence : NOT_SORTED;\n      const defaultSorting = sortDirection && (sortPrecedence > NOT_SORTED) ? sortDirection.toLowerCase() : 'none';\n\n      setProperties(c, {\n        defaultVisible: !get(c, 'isHidden'),\n        sorting: defaultSorting,\n        sortPrecedence: defaultSortPrecedence\n      });\n\n      if (get(c, 'filterWithSelect') && get(c, 'useFilter')) {\n        let predefinedFilterOptions = get(column, 'predefinedFilterOptions');\n        let usePredefinedFilterOptions = 'array' === typeOf(predefinedFilterOptions);\n        if (usePredefinedFilterOptions && get(predefinedFilterOptions, 'length')) {\n          const types = A(['object', 'instance']);\n          const allObjects = A(predefinedFilterOptions).every(option => types.includes(typeOf(option)) && option.hasOwnProperty('label') && option.hasOwnProperty('value'));\n          const allPrimitives = A(predefinedFilterOptions).every(option => !types.includes(typeOf(option)));\n          assert('`predefinedFilterOptions` should be an array of objects or primitives and not mixed', allObjects || allPrimitives);\n          if (allPrimitives) {\n            predefinedFilterOptions = predefinedFilterOptions.map(optionStrToObj);\n          }\n          if ('' !== predefinedFilterOptions[0].value) {\n            predefinedFilterOptions = [{value: '', label: ''}, ...predefinedFilterOptions];\n          }\n          set(c, 'filterOptions', usePredefinedFilterOptions ? predefinedFilterOptions : []);\n        }\n        else if (usePredefinedFilterOptions) {\n          // Empty array as predefined filter\n          set(c, 'useFilter', false);\n        }\n        else {\n          if (propertyName) {\n            set(c, 'filterOptions', getFilterOptionsCP(propertyName));\n          }\n        }\n      }\n      return c;\n    }));\n    nColumns.filterBy('propertyName').forEach(column => {\n      let propertyName = get(column, 'propertyName');\n      if (isNone(get(column, 'title'))) {\n        set(column, 'title', propertyNameToTitle(propertyName));\n      }\n    });\n    set(this, 'processedColumns', nColumns);\n\n    // Apply initial sorting\n    set(this, 'sortProperties', A());\n    const filteredOrderedColumns = nColumns.sortBy('sortPrecedence').filter(col => isSortedByDefault(col));\n    filteredOrderedColumns.forEach(column => {\n      self.send('sort', column);\n      const defaultSortedBy = column.sortedBy || column.propertyName;\n      let sortingArgs = [column, defaultSortedBy, column.sortDirection.toLowerCase()];\n      if (get(this, 'multipleColumnsSorting')) {\n        this._multiColumnsSorting(...sortingArgs);\n      }\n      else {\n        this._singleColumnSorting(...sortingArgs);\n      }\n    });\n  },\n\n  /**\n   * Update messages used by widget with custom values provided by user in the <code>customMessages</code>\n   *\n   * @method _setupMessages\n   * @returns {undefined}\n   * @private\n   */\n  _setupMessages: observer('customMessages', function () {\n    const customIcons = getWithDefault(this, 'customMessages', {});\n    let newMessages = {};\n    assign(newMessages, defaultMessages, customIcons);\n    set(this, 'messages', O.create(newMessages));\n  }),\n\n  /**\n   * Provide backward compatibility with <code>pageSizeValues</code> equal to an array with numbers and not objects\n   * <code>pageSizeValues</code> is live as is, <code>pageSizeOptions</code> is used in the templates\n   *\n   * @method _setupPageSizeOptions\n   * @returns {undefined}\n   * @private\n   */\n  _setupPageSizeOptions() {\n    let pageSizeOptions = get(this, 'pageSizeValues').map(optionStrToObj);\n    set(this, 'pageSizeOptions', pageSizeOptions);\n  },\n\n  /**\n   * Set <code>sortProperties</code> when single-column sorting is used\n   *\n   * @param {ModelsTableColumn} column\n   * @param {string} sortedBy\n   * @param {string} newSorting 'asc|desc|none'\n   * @method _singleColumnSorting\n   * @returns {undefined}\n   * @private\n   */\n  _singleColumnSorting(column, sortedBy, newSorting) {\n    get(this, 'processedColumns').setEach('sorting', 'none');\n    set(column, 'sorting', newSorting);\n    set(this, 'sortProperties', 'none' === newSorting ? [] : [`${sortedBy}:${newSorting}`]);\n  },\n\n  /**\n   * Set <code>sortProperties</code> when multi-columns sorting is used\n   *\n   * @param {ModelsTableColumn} column\n   * @param {string} sortedBy\n   * @param {string} newSorting 'asc|desc|none'\n   * @method _multiColumnsSorting\n   * @returns {undefined}\n   * @private\n   */\n  _multiColumnsSorting(column, sortedBy, newSorting) {\n    set(column, 'sorting', newSorting);\n    let sortProperties = get(this, 'sortProperties');\n    let sortPropertiesMap = {};\n    sortProperties.forEach(p => {\n      let [propertyName, order] = p.split(':');\n      sortPropertiesMap[propertyName] = order;\n    });\n    delete sortPropertiesMap[sortedBy];\n\n    let newSortProperties = A([]);\n    keys(sortPropertiesMap).forEach(propertyName => {\n      if (propertyName !== sortedBy) {\n        newSortProperties.pushObject(`${propertyName}:${sortPropertiesMap[propertyName]}`);\n      }\n    });\n    if ('none' !== newSorting) {\n      newSortProperties.pushObject(`${sortedBy}:${newSorting}`);\n    }\n    set(this, 'sortProperties', newSortProperties);\n  },\n\n  /**\n   * send <code>displayDataChangedAction</code>-action when user does sort of filter\n   * action is sent only if <code>sendDisplayDataChangedAction</code> is true (default false)\n   *\n   * @method userInteractionObserver\n   * @returns {undefined}\n   * @private\n   */\n  userInteractionObserver () {\n    run.once(this, this.userInteractionObserverOnce);\n  },\n\n  /**\n   * @method userInteractionObserverOnce\n   * @returns {undefined}\n   * @private\n   */\n  userInteractionObserverOnce() {\n    if (get(this, 'sendDisplayDataChangedAction')) {\n      let columns = get(this, 'processedColumns');\n      let settings = O.create({\n        sort: get(this, 'sortProperties'),\n        currentPageNumber: get(this, 'currentPageNumber'),\n        pageSize: parseInt(get(this, 'pageSize'), 10),\n        filterString: get(this, 'filterString'),\n        filteredContent: get(this, 'filteredContent'),\n        selectedItems: get(this, '_selectedItems'),\n        expandedRowIndexes: get(this, '_expandedRowIndexes'),\n        columnFilters: {}\n      });\n      columns.forEach(column => {\n        if (!isBlank(get(column, 'filterString'))) {\n          settings.columnFilters[get(column, 'propertyName')] = get(column, 'filterString');\n        }\n      });\n      this.sendAction('displayDataChangedAction', settings);\n    }\n  },\n\n  /**\n   * send <code>columnsVisibilityChangedAction</code>-action when user changes which columns are visible\n   * action is sent only if <code>sendColumnsVisibilityChangedAction</code> is true (default false)\n   *\n   * @returns {undefined}\n   * @method _sendColumnsVisibilityChangedAction\n   * @private\n   */\n  _sendColumnsVisibilityChangedAction() {\n    if (get(this, 'sendColumnsVisibilityChangedAction')) {\n      let columns = get(this, 'processedColumns');\n      let columnsVisibility = columns.map(column => {\n        let options = getProperties(column, 'isHidden', 'mayBeHidden', 'propertyName');\n        options.isHidden = !!options.isHidden;\n        return options;\n      });\n      this.sendAction('columnsVisibilityChangedAction', columnsVisibility);\n    }\n  },\n\n  /**\n   * Force <code>arrangedContent</code> to be updated when <code>sortProperties</code> is changed\n   * Currently \"normal\" <code>Em.computed.sort</code> has issue when sort properties is empty\n   *\n   * @method forceUpdateArrangedContent\n   * @returns {undefined}\n   * @private\n   */\n  forceUpdateArrangedContent: observer('filteredContent.[]', 'sortProperties.[]', function () {\n    this.notifyPropertyChange('arrangedContent');\n  }),\n\n  /**\n   * Handler for global filter and filter by each column\n   *\n   * @method filteringApplied\n   * @returns {undefined}\n   * @private\n   */\n  filteringApplied: observer('filterString', 'processedColumns.@each.filterString', function () {\n    set(this, 'currentPageNumber', 1);\n    this.userInteractionObserver();\n  }),\n\n  /**\n   * Handler for <code>pageSize</code> changing\n   *\n   * @method paginationApplied\n   * @returns {undefined}\n   * @private\n   */\n  paginationApplied: observer('pageSize', function () {\n    set(this, 'currentPageNumber', 1);\n    this.userInteractionObserver();\n  }),\n\n  /**\n   * Collapse open rows when user change page size or moved to the another page\n   *\n   * @method collapseRowOnNavigate\n   * @returns {undefined}\n   * @private\n   */\n  collapseRowOnNavigate: observer('currentPageNumber', 'pageSize', function () {\n    set(this, '_expandedRowIndexes', A([]));\n  }),\n\n  /**\n   * Rebuild the whole table.\n   * This can be called to force a complete re-render of the table.\n   *\n   * @method rebuildTable\n   * @returns {undefined}\n   */\n  rebuildTable() {\n    set(this, 'currentPageNumber', 1);\n    this._clearFilters();\n    this.setup();\n  },\n\n  /**\n   * Clear all filters.\n   *\n   * @method _clearFilters\n   * @returns {undefined}\n   * @private\n   */\n  _clearFilters() {\n    set(this, 'filterString', '');\n    get(this, 'processedColumns').setEach('filterString', '');\n  },\n\n  /**\n   * @type Object\n   */\n  actions: {\n\n    /**\n     * @method actions.sendAction\n     * @returns {undefined}\n     */\n    sendAction () {\n      this.sendAction(...arguments);\n    },\n\n    /**\n     * @method actions.toggleHidden\n     * @param {ModelsTableColumn} column\n     * @returns {undefined}\n     */\n    toggleHidden (column) {\n      if (get(column, 'mayBeHidden')) {\n        column.toggleProperty('isHidden');\n        this._sendColumnsVisibilityChangedAction();\n      }\n    },\n\n    /**\n     * @method actions.showAllColumns\n     * @returns {undefined}\n     */\n    showAllColumns () {\n      get(this, 'processedColumns').setEach('isHidden', false);\n      this._sendColumnsVisibilityChangedAction();\n    },\n\n    /**\n     * @method actions.hideAllColumns\n     * @returns {undefined}\n     */\n    hideAllColumns () {\n      A(get(this, 'processedColumns').filterBy('mayBeHidden')).setEach('isHidden', true);\n      this._sendColumnsVisibilityChangedAction();\n    },\n\n    /**\n     * @method actions.restoreDefaultVisibility\n     * @returns {undefined}\n     */\n    restoreDefaultVisibility() {\n      get(this, 'processedColumns').forEach(c => {\n        set(c, 'isHidden', !get(c, 'defaultVisible'));\n        this._sendColumnsVisibilityChangedAction();\n      });\n    },\n\n    /**\n     * @method actions.toggleColumnSet\n     * @returns {undefined}\n     */\n    toggleColumnSet({ showColumns = [], hideOtherColumns, toggleSet = false } = {}) {\n      let columns = get(this, 'processedColumns');\n\n      // If hideOtherColumns is not set, default to true if toggleSet=false, else to false\n      hideOtherColumns = isNone(hideOtherColumns) ? !toggleSet : hideOtherColumns;\n\n      // If showColumns is a function, call it\n      if (typeOf(showColumns) === 'function') {\n        return run(this, showColumns, columns);\n      }\n\n      let setColumns = A([]);\n      let otherColumns = A([]);\n\n      columns.forEach((column) => {\n        let columnId = get(column, 'propertyName');\n\n        if (!columnId || !get(column, 'mayBeHidden')) {\n          return;\n        }\n\n        showColumns = A(showColumns);\n        if (showColumns.includes(columnId)) {\n          setColumns.pushObject(column);\n        } else {\n          otherColumns.pushObject(column);\n        }\n      });\n\n      // By default, all columns should always be set to visible\n      // However, if `toggleSet=true`, then the set should be toggled between visible/hidden\n      // In this case, if one of the set columns is hidden, make them all visible, else hide them\n      let targetVisibility = true;\n      if (toggleSet) {\n        targetVisibility = !!setColumns.findBy('isVisible', false);\n      }\n\n      setColumns.forEach((column) => {\n        let columnId = get(column, 'propertyName');\n        if (showColumns.includes(columnId) && get(column, 'isVisible') !== targetVisibility) {\n          this.send('toggleHidden', column);\n        }\n      });\n\n      if (hideOtherColumns) {\n        otherColumns.forEach((column) => {\n          let columnId = get(column, 'propertyName');\n\n          if (!showColumns.includes(columnId) && get(column, 'isVisible')) {\n            this.send('toggleHidden', column);\n          }\n        });\n      }\n    },\n\n    /**\n     * @param {number} pageNumber\n     * @method actions.gotoCustomPage\n     * @returns {undefined}\n     */\n    gotoCustomPage (pageNumber) {\n      set(this, 'currentPageNumber', pageNumber);\n      this.userInteractionObserver();\n    },\n\n    /**\n     * @method actions.sort\n     * @param {ModelsTableColumn} column\n     * @returns {undefined}\n     */\n    sort (column) {\n      const sortMap = {\n        none: 'asc',\n        asc: 'desc',\n        desc: 'none'\n      };\n      let sortedBy = get(column, 'sortedBy') || get(column, 'propertyName');\n      if (isNone(sortedBy)) {\n        return;\n      }\n      let currentSorting = get(column, 'sorting');\n      let newSorting = sortMap[currentSorting.toLowerCase()];\n      let sortingArgs = [column, sortedBy, newSorting];\n      if (get(this, 'multipleColumnsSorting')) {\n        this._multiColumnsSorting(...sortingArgs);\n      }\n      else {\n        this._singleColumnSorting(...sortingArgs);\n      }\n      set(this, 'currentPageNumber', 1);\n      this.userInteractionObserver();\n    },\n\n    /**\n     * @param {number} index\n     * @returns {undefined}\n     * @method actions.expandRow\n     */\n    expandRow(index) {\n      assert(`row index should be numeric`, typeOf(index) === 'number');\n      let multipleExpand = get(this, 'multipleExpand');\n      let expandedRowIndexes = get(this, '_expandedRowIndexes');\n      if (multipleExpand) {\n        expandedRowIndexes.pushObject(index);\n      }\n      else {\n        if (expandedRowIndexes.length === 1) {\n          expandedRowIndexes.clear();\n        }\n        expandedRowIndexes.pushObject(index);\n      }\n      set(this, '_expandedRowIndexes', expandedRowIndexes);\n      this.userInteractionObserver();\n    },\n\n    /**\n     * @param {number} index\n     * @returns {undefined}\n     * @method actions.collapseRow\n     */\n    collapseRow(index) {\n      assert(`row index should be numeric`, typeOf(index) === 'number');\n      let expandedRowIndexes = get(this, '_expandedRowIndexes').without(index);\n      set(this, '_expandedRowIndexes', expandedRowIndexes);\n      this.userInteractionObserver();\n    },\n\n    /**\n     * @method actions.expandAllRows\n     * @returns {undefined}\n     */\n    expandAllRows() {\n      let multipleExpand = get(this, 'multipleExpand');\n      let expandedRowIndexes = get(this, '_expandedRowIndexes');\n      let visibleContentLength = get(this, 'visibleContent.length');\n      if (multipleExpand) {\n        expandedRowIndexes.clear();\n        expandedRowIndexes.pushObjects(generateIndexes(visibleContentLength));\n        this.userInteractionObserver();\n      }\n    },\n\n    /**\n     * @method actions.collapseAllRows\n     * @returns {undefined}\n     */\n    collapseAllRows() {\n      get(this, '_expandedRowIndexes').clear();\n      this.userInteractionObserver();\n    },\n\n    /**\n     * Handler for row-click\n     * Toggle <code>selected</code>-state for row\n     * Select only one or multiple rows depends on <code>multipleSelect</code>-value\n     *\n     * @param {number} index\n     * @param {object} dataItem\n     * @returns {undefined}\n     * @method actions.clickOnRow\n     */\n    clickOnRow(index, dataItem) {\n      assert(`row index should be numeric`, typeOf(index) === 'number');\n      if (get(this, 'selectRowOnClick')) {\n        let multipleSelect = get(this, 'multipleSelect');\n        let selectedItems = get(this, '_selectedItems');\n        if (selectedItems.includes(dataItem)) {\n          selectedItems = selectedItems.without(dataItem);\n          set(this, '_selectedItems', selectedItems);\n        }\n        else {\n          if (multipleSelect) {\n            get(this, '_selectedItems').pushObject(dataItem);\n          }\n          else {\n            if(selectedItems.length === 1) {\n              get(this, '_selectedItems').clear();\n            }\n            get(this, '_selectedItems').pushObject(dataItem);\n          }\n        }\n      }\n      this.userInteractionObserver();\n    },\n\n    /**\n     * Clear all column filters and global filter\n     * @returns {undefined}\n     * @method actions.clearFilters\n     */\n    clearFilters() {\n      this._clearFilters();\n    },\n\n    /**\n     * Dummy action for internal use\n     * @method actions.emptyAction\n     * @returns {undefined}\n     */\n    emptyAction() {\n      return true;\n    },\n\n    /**\n     * Select/deselect all rows\n     * @method actions.toggleAllSelection\n     * @returns {undefined}\n     */\n    toggleAllSelection() {\n      let selectedItems = get(this, '_selectedItems');\n      let data = get(this, 'data');\n      if(selectedItems.length === data.get('length')) {\n        get(this, '_selectedItems').clear();\n      }\n      else {\n        set(this, '_selectedItems', A(data.slice()));\n      }\n      this.userInteractionObserver();\n    }\n  }\n\n});\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- addon/components/models-table.js	(revision cca7c13bfc4d98258e34d628a10ea298679bf05b)
+++ addon/components/models-table.js	(revision )
@@ -869,6 +869,7 @@
       assert('`columnFieldsToCheckUpdate` should be an array of strings', 'array' === typeOf(columnFieldsToCheckUpdate));
       columnFieldsToCheckUpdate.forEach(propertyName => this.addObserver(`columns.@each.${propertyName}`, this, this._setupColumnsOnce));
     }
+    this.addObserver('processedColumns.@each.filterString', this, this.filteringApplied);
     this.addObserver('visibleContent.length', this, this.visibleContentObserver);
   }),
 
@@ -1195,7 +1196,7 @@
    * @returns {undefined}
    * @private
    */
-  filteringApplied: observer('filterString', 'processedColumns.@each.filterString', function () {
+  filteringApplied: observer('filterString', function () {
     set(this, 'currentPageNumber', 1);
     this.userInteractionObserver();
   }),
Index: tests/integration/components/models-table-test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import { A } from '@ember/array';\nimport O from '@ember/object';\nimport BootstrapTheme from 'ember-models-table/themes/bootstrap';\n\nimport {\n  moduleForComponent,\n  test\n} from 'ember-qunit';\n\nimport hbs from 'htmlbars-inline-precompile';\n\nimport {\n  generateContent,\n  generateColumns\n} from '../../helpers/f';\n\nimport ModelsTableBs from '../../pages/models-table-bs';\n\nconst {\n  rows,\n  navigation,\n  filters,\n  sorting,\n  headers,\n  rowExpands,\n  columnsDropDown\n} = ModelsTableBs;\n\nconst oneTenArray = ['one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten'];\nconst oneTenArrayDig = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'];\nconst tenOneArrayDig = oneTenArrayDig.slice().reverse();\nconst oneTenAscArray = ['eight', 'five', 'four', 'nine', 'one', 'seven', 'six', 'ten', 'three', 'two'];\nconst oneTenDescArray = ['two', 'three', 'ten', 'six', 'seven', 'one', 'nine', 'four', 'five', 'eight'];\n\nmoduleForComponent('models-table', 'ModelsTable | Integration', {\n  integration: true,\n\n  beforeEach() {\n    ModelsTableBs.setContext(this);\n  },\n\n  afterEach() {\n    ModelsTableBs.removeContext();\n  }\n\n});\n\nfunction signFilter (cellValue, neededString) {\n  const signs = ['<', '>', '='];\n  let neededNumber = neededString;\n  let sign = '=';\n  if (-1 !== signs.indexOf(neededString[0])) {\n    sign = neededString[0];\n    neededNumber = parseInt(neededString.substring(1), 10);\n  }\n  let _cellValue = parseInt(cellValue, 10);\n  if ('=' === sign) {\n    return _cellValue === neededNumber;\n  }\n  if ('>' === sign) {\n    return _cellValue > neededNumber;\n  }\n  if ('<' === sign) {\n    return _cellValue < neededNumber;\n  }\n  return cellValue === neededNumber;\n}\n\ntest('summary', function (assert) {\n\n  this.setProperties({\n    data: A([]),\n    columns: generateColumns(['index'])\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n  assert.equal(ModelsTableBs.summary, 'Show 0 - 0 of 0', 'Empty content');\n\n  this.set('data', generateContent(10));\n  assert.equal(ModelsTableBs.summary, 'Show 1 - 10 of 10', 'Content for 1 page');\n\n  this.set('data', generateContent(15));\n  navigation.goToNextPage();\n  assert.equal(ModelsTableBs.summary, 'Show 11 - 15 of 15', 'Content for 2 pages. Last page selected');\n\n  this.set('data', generateContent(35));\n  assert.equal(ModelsTableBs.summary, 'Show 11 - 20 of 35', 'Content for 4 pages. Middle page selected');\n\n});\n\ntest('basic render', function (assert) {\n\n  this.setProperties({\n    columns: generateColumns(['index', 'reversedIndex']),\n    data: generateContent(10, 1)\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n\n  assert.equal(ModelsTableBs.tablesCount, 1, 'Table exists');\n  assert.equal(rows().count, 10, 'Table has 10 rows');\n  assert.equal(ModelsTableBs.summary, 'Show 1 - 10 of 10', 'Summary is valid');\n  assert.equal(navigation.disabledNavigationLinksCount, 4, 'All navigation buttons are disabled');\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), oneTenArrayDig, 'Content is valid');\n\n});\n\ntest('basic render with data update', function (assert) {\n  this.set('data', generateContent(10, 1));\n  this.set('columns', generateColumns(['index', 'reversedIndex']));\n\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n  assert.equal(ModelsTableBs.tablesCount, 1, 'Table exists');\n  assert.equal(rows().count, 10, 'Table has 10 rows');\n  assert.equal(ModelsTableBs.summary, 'Show 1 - 10 of 10', 'Summary is valid');\n  assert.equal(navigation.disabledNavigationLinksCount, 4, 'All navigation buttons are disabled');\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), oneTenArrayDig, 'Content is valid');\n\n  this.set('data.0.index', 11);\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['11', '2', '3', '4', '5', '6', '7', '8', '9', '10'], 'Content is valid after update');\n\n  this.set('data.firstObject.index', 12);\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['12', '2', '3', '4', '5', '6', '7', '8', '9', '10'], 'Content is valid after second update');\n\n});\n\ntest('render without footer', function (assert) {\n\n  this.set('showComponentFooter', false);\n  this.render(hbs`{{models-table showComponentFooter=showComponentFooter}}`);\n\n  assert.equal(ModelsTableBs.tableFooterCount, 0, 'table footer isn\\'t rendered');\n\n});\n\ntest('pageSizeObserver', function (assert) {\n\n  this.set('data', generateContent(50, 1));\n  this.render(hbs`{{models-table data=data}}`);\n\n  assert.equal(ModelsTableBs.summary, 'Show 1 - 10 of 50', 'init value');\n  navigation.goToNextPage();\n\n  assert.equal(ModelsTableBs.summary, 'Show 11 - 20 of 50', 'value changed by user');\n  ModelsTableBs.changePageSize(25);\n\n  assert.equal(ModelsTableBs.summary, 'Show 1 - 25 of 50', 'value restored to 1');\n\n});\n\ntest('visibleContent', function (assert) {\n\n  this.setProperties({\n    columns: generateColumns(['index']),\n    data: generateContent(10),\n    pageSize: 10,\n    currentPageNumber: 1\n  });\n\n  this.render(hbs`{{models-table data=data currentPageNumber=currentPageNumber pageSize=pageSize columns=columns}}`);\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), generateContent(10).mapBy('index').map(c => `${c}`), 'One page');\n\n  this.setProperties({\n    data: generateContent(25, 1),\n    currentPageNumber: 2\n  });\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), generateContent(10, 11).mapBy('index').map(c => `${c}`), 'Second page');\n\n  this.setProperties({\n    data: generateContent(25, 1),\n    currentPageNumber: 1,\n    pageSize: 50\n  });\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), generateContent(25, 1).mapBy('index').map(c => `${c}`), 'One big page');\n\n  this.setProperties({\n    data: generateContent(25, 1),\n    currentPageNumber: 3,\n    pageSize: 10\n  });\n  navigation.goToNextPage();\n  navigation.goToNextPage();\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), generateContent(5, 21).mapBy('index').map(c => `${c}`), 'Last page');\n\n});\n\ntest('visibleContent with page size changing and pagination', function (assert) {\n\n  this.setProperties({\n    data: generateContent(1000, 1),\n    columns: generateColumns(['index'])\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n\n  ModelsTableBs.changePageSize(25);\n  assert.equal(rows().count, 25, '1st page has 25 rows');\n\n  navigation.goToNextPage();\n  assert.equal(rows().count, 25, '2nd page has 25 rows');\n\n  navigation.goToNextPage();\n  assert.equal(rows().count, 25, '3rd page has 25 rows');\n\n});\n\ntest('gotoBackEnabled', function (assert) {\n\n  this.setProperties({\n    data: generateContent(25, 1),\n    columns: generateColumns(['index'])\n  });\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n\n  assert.ok(navigation.goToPrevPageDisabled, 'Disabled, if user is on the 1st page');\n\n  navigation.goToNextPage();\n  assert.notOk(navigation.goToPrevPageDisabled, `Enabled, if user isn't on the 1st page`);\n\n});\n\ntest('gotoForwardEnabled', function (assert) {\n\n  this.setProperties({\n    data: generateContent(10),\n    columns: generateColumns(['id'])\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n  assert.ok(navigation.goToNextPageDisabled, 'One page only');\n\n  this.set('data', generateContent(11));\n  assert.notOk(navigation.goToNextPageDisabled, `'One page + 1 record more`);\n\n  this.setProperties({\n    data: generateContent(25)\n  });\n  navigation.goToNextPage();\n  navigation.goToNextPage();\n  navigation.goToNextPage();\n  assert.ok(navigation.goToNextPageDisabled, 'Three pages, last one selected');\n\n});\n\ntest('render multi-pages table', function (assert) {\n\n  this.setProperties({\n    columns: generateColumns(['index', 'reversedIndex']),\n    data: generateContent(20, 1)\n  });\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n\n  assert.notOk(navigation.goToNextPageDisabled, 'next enabled');\n  assert.notOk(navigation.goToLastPageDisabled, 'last enabled');\n  assert.ok(navigation.goToPrevPageDisabled, 'prev disabled');\n  assert.ok(navigation.goToFirstPageDisabled, 'first disabled');\n  assert.equal(ModelsTableBs.summary, 'Show 1 - 10 of 20', 'Summary is valid');\n\n  navigation.goToNextPage();\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['11', '12', '13', '14', '15', '16', '17', '18', '19', '20'], 'Content is valid');\n  assert.ok(navigation.goToNextPageDisabled, 'next disabled');\n  assert.ok(navigation.goToLastPageDisabled, 'last disabled');\n  assert.notOk(navigation.goToPrevPageDisabled, 'prev enabled');\n  assert.notOk(navigation.goToFirstPageDisabled, 'first enabled');\n\n});\n\ntest('render custom component in the table cell', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[1].component = 'cell-component';\n  this.setProperties({\n    data: generateContent(20, 1),\n    columns\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), oneTenArray, 'Content is valid');\n\n});\n\ntest('render custom component (input) in the filter cell', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[1].componentForFilterCell = 'filter-cell-input';\n\n  this.setProperties({\n    data: generateContent(10, 1),\n    columns\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), oneTenArray, 'Content is valid');\n\n  filters(1).inputFilter('one');\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), ['one'], 'Content is filtered');\n\n  filters(1).clearFilter();\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), oneTenArray, 'Content is restored');\n\n});\n\ntest('render custom component (select) in the filter cell', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[1].componentForFilterCell = 'filter-cell-select';\n\n  this.setProperties({\n    data: generateContent(10, 1),\n    columns\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n  assert.deepEqual(filters(1).selectOptions, ['', ...oneTenArray], 'Filter options are correct');\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), oneTenArray, 'Content is valid');\n\n  filters(1).selectFilter('one');\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), ['one'], 'Content is filtered');\n\n  filters(1).clearFilter();\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), oneTenArray, 'Content is restored');\n\n});\n\ntest('render custom component in the sort cell', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[1].componentForSortCell = 'sort-cell';\n\n  this.setProperties({\n    data: generateContent(10, 1),\n    columns\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data multipleColumnsSorting=false}}`);\n  sorting(1).click();\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), oneTenAscArray, 'Content is valid (sorting 2nd column asc)');\n\n  sorting(1).click();\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), oneTenDescArray, 'Content is valid (sorting 2nd column desc)');\n\n});\n\ntest('render show/hide columns', function (assert) {\n\n  const firstColumnIconSelector = '.columns-dropdown li:nth-child(5) a span';\n  const secondColumnIconSelector = '.columns-dropdown li:nth-child(6) a span';\n  const checkedClass = 'glyphicon-check';\n  const uncheckedClass = 'glyphicon-unchecked';\n  this.setProperties({\n    columns: generateColumns(['index', 'reversedIndex']),\n    data: generateContent(10, 1)\n  });\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n\n  assert.equal(sorting().count, 2, '2 columns are shown (thead)');\n  assert.equal(filters().count, 2, '2 columns are shown (thead)');\n  assert.equal(rows(0).cells().count, 2, '2 columns are shown (tbody)');\n\n  columnsDropDown(3).click();\n\n  assert.equal(sorting().count, 1, '1 column is shown (thead)');\n  assert.equal(filters().count, 1, '1 column is shown (thead)');\n  assert.equal(rows(0).cells().count, 1, '1 column is shown (tbody)');\n  assert.deepEqual(sorting().mapBy('title'), ['reversedIndex'], 'Valid column is shown (thead)');\n  assert.equal(this.$(firstColumnIconSelector).hasClass(uncheckedClass), true, 'First column is unchecked');\n  assert.equal(this.$(secondColumnIconSelector).hasClass(checkedClass), true, 'Second column is checked');\n\n  columnsDropDown(3).click();\n\n  assert.equal(sorting().count, 2, '2 columns are shown (thead)');\n  assert.equal(filters().count, 2, '2 columns are shown (tbody)');\n  assert.equal(this.$(firstColumnIconSelector).hasClass(checkedClass), true, 'First column is checked');\n  assert.equal(this.$(secondColumnIconSelector).hasClass(checkedClass), true, 'Second column is checked');\n\n  columnsDropDown(4).click();\n\n  assert.equal(sorting().count, 1, '1 column is shown (thead)');\n  assert.equal(filters().count, 1, '1 column is shown (tbody)');\n  assert.deepEqual(sorting().mapBy('title'), ['index'], 'Valid column is shown (thead)');\n  assert.equal(this.$(firstColumnIconSelector).hasClass(checkedClass), true, 'First column is checked');\n  assert.equal(this.$(secondColumnIconSelector).hasClass(uncheckedClass), true, 'Second column is unchecked');\n\n  columnsDropDown(3).click();\n\n  assert.equal(rows().count, 1, '1 row is shown when all columns are hidden');\n  assert.equal(ModelsTableBs.getCellsCount(), 1, 'with 1 cell');\n  assert.equal(rows(0).getCellColspans(), 2, 'it\\'s colspan is equal to the columns count');\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['All columns are hidden. Use columns-dropdown to show some of them'], 'correct message is shown');\n  assert.equal(this.$(firstColumnIconSelector).hasClass(uncheckedClass), true, 'First column is unchecked');\n  assert.equal(this.$(secondColumnIconSelector).hasClass(uncheckedClass), true, 'Second column is unchecked');\n\n});\n\ntest('render show/hide all columns', function(assert) {\n  this.setProperties({\n    columns: generateColumns(['index', 'reversedIndex']),\n    data: generateContent(10, 1)\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n  assert.equal(sorting().count, 2, '2 columns are shown (thead)');\n  assert.equal(filters().count, 2, '2 columns are shown (thead)');\n  assert.equal(rows(0).cells().count, 2, '2 columns are shown (tbody)');\n\n  columnsDropDown(1).click();\n\n  assert.equal(rows().count, 1, '1 row is shown when all columns are hidden');\n  assert.equal(ModelsTableBs.getCellsCount(), 1, 'with 1 cell');\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['All columns are hidden. Use columns-dropdown to show some of them'], 'correct message is shown');\n\n  columnsDropDown(0).click();\n\n  assert.equal(sorting().count, 2, '2 columns are shown (thead)');\n  assert.equal(filters().count, 2, '2 columns are shown (thead)');\n  assert.equal(rows(0).cells().count, 2, '2 columns are shown (tbody)');\n\n});\n\ntest('render columns-dropdown with mayBeHidden = false for some columns', function (assert) {\n\n  const columns = generateColumns(['index', 'reversedIndex']);\n  columns[0].mayBeHidden = false;\n  this.setProperties({\n    columns,\n    data: generateContent(10, 1)\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n  assert.deepEqual(columnsDropDown().mapBy('label'), ['Show All', 'Hide All', 'Restore Defaults', 'reversedIndex'], 'Column with mayBeHidden = false is not shown in the columns dropdown');\n\n  columnsDropDown(3).click();\n\n  assert.equal(sorting().count, 1, '1 column are shown (thead)');\n  assert.equal(filters().count, 1, '1 column are shown (thead)');\n  assert.equal(rows(0).cells().count, 1, '1 column are shown (tbody)');\n  assert.deepEqual(sorting().mapBy('title'), ['index'], 'Valid column is shown (thead)');\n\n  columnsDropDown(3).click();\n  assert.equal(sorting().count, 2, '2 columns are shown (thead)');\n\n  columnsDropDown(1).click();\n  assert.equal(sorting().count, 1, '1 column are shown (thead)');\n  assert.equal(filters().count, 1, '1 column are shown (thead)');\n  assert.equal(rows(0).cells().count, 1, '1 column are shown (tbody)');\n  assert.deepEqual(sorting().mapBy('title'), ['index'], 'Valid column is shown (thead)');\n\n});\n\ntest('render columnSets in columns-dropdown', function(assert) {\n  let customFunctionCalled = null;\n  this.setProperties({\n    columns: generateColumns(['index', 'index2', 'reversedIndex', 'id']),\n    data: generateContent(10, 1),\n    columnSets: [\n      {\n        label: 'Set 1',\n        showColumns: ['index', 'id']\n      },\n      {\n        label: 'Set 2',\n        showColumns: ['index', 'id'],\n        hideOtherColumns: false\n      },\n      {\n        label: 'Set 3',\n        showColumns: ['index', 'id'],\n        toggleSet: true\n      },\n      {\n        label: 'Set 4',\n        showColumns(columns) {\n          customFunctionCalled = columns;\n        }\n      }\n    ]\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data columnSets=columnSets}}`);\n  assert.equal(sorting().count, 4, '4 columns are shown (thead)');\n  assert.equal(filters().count, 4, '4 columns are shown (thead)');\n  assert.equal(rows(0).cells().count, 4, '4 columns are shown (tbody)');\n\n  columnsDropDown(1).click();\n  columnsDropDown(3).click();\n  assert.equal(rows(0).cells().count, 2, '2 columns are shown for default settings');\n\n  columnsDropDown(3).click();\n  assert.equal(rows(0).cells().count, 2, '2 columns are still shown after repeated click');\n\n  columnsDropDown(0).click();\n  columnsDropDown(3).click();\n  assert.equal(rows(0).cells().count, 2, 'other columns are hidden if hideOtherColumns=true');\n\n  columnsDropDown(0).click();\n  columnsDropDown(7).click(); // This is the first regular column\n  columnsDropDown(4).click();\n  assert.equal(rows(0).cells().count, 4, 'other columns are not hidden if hideOtherColumns=false');\n\n  columnsDropDown(4).click();\n  assert.equal(rows(0).cells().count, 4, 'columns remain visible after repeated click with hideOtherColumns=false');\n\n  columnsDropDown(5).click();\n  assert.equal(rows(0).cells().count, 2, 'columns are hidden if toggleSet=true and both columns are visible');\n\n  columnsDropDown(5).click();\n  assert.equal(rows(0).cells().count, 4, 'columns are shown if toggleSet=true and both columns are hidden');\n\n  columnsDropDown(7).click(); // This is the first regular column\n  columnsDropDown(5).click();\n  assert.equal(rows(0).cells().count, 4, 'columns are shown if toggleSet=true and one of them is hidden');\n\n  columnsDropDown(6).click();\n  assert.ok(customFunctionCalled, 'custom function is called if showColumns is a function');\n  assert.deepEqual(customFunctionCalled.mapBy('propertyName'), ['index', 'index2', 'reversedIndex', 'id'], 'custom function gets columns as argument');\n});\n\ntest('global filtering (ignore case OFF)', function(assert) {\n\n  const columns = generateColumns(['index', 'reversedIndex']);\n  this.setProperties({\n    columns,\n    data: generateContent(10, 1)\n  });\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n\n  ModelsTableBs.doGlobalFilter('1');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['1', '10'], 'Content is filtered correctly');\n\n  ModelsTableBs.doGlobalFilter('');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), oneTenArrayDig, 'Filter is empty and all rows are shown');\n\n  ModelsTableBs.doGlobalFilter('invalid input');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['No records to show'], 'All rows are filtered out and proper message is shown');\n  assert.equal(rows(0).getCellColspans(), columns.length, 'cell with message has correct colspan');\n\n});\n\ntest('global filtering (ignore case ON)', function(assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  this.setProperties({\n      filteringIgnoreCase: true,\n      columns,\n      data: generateContent(10, 1)\n  });\n  this.render(hbs`{{models-table columns=columns data=data filteringIgnoreCase=filteringIgnoreCase}}`);\n\n  ModelsTableBs.doGlobalFilter('One');\n\n  assert.deepEqual(rows(0).cells().mapBy('content'), ['1', 'one'], 'Content is filtered correctly');\n\n  ModelsTableBs.doGlobalFilter('');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), oneTenArrayDig, 'Filter is empty and all rows are shown');\n\n  ModelsTableBs.doGlobalFilter('invalid input');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['No records to show'], 'All rows are filtered out and proper message is shown');\n  assert.equal(rows(0).getCellColspans(), columns.length, 'cell with message has correct colspan');\n\n  ModelsTableBs.doGlobalFilter('');\n  sorting(0).click();\n  sorting(0).click();\n\n  ModelsTableBs.doGlobalFilter('One');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), ['one'], 'Content is filtered correctly when sorting is not done');\n\n});\n\ntest('filtering by columns (ignore case OFF)', function (assert) {\n\n  const columns = generateColumns(['index', 'reversedIndex']);\n  columns[0].filterPlaceholder = 'custom placeholder';\n  this.setProperties({\n    columns,\n    data: generateContent(10, 1),\n    useFilteringByColumns: true\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns useFilteringByColumns=useFilteringByColumns}}`);\n  filters(0).inputFilter('1');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['1', '10'], 'Content is filtered correctly');\n\n  filters(0).inputFilter('');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), oneTenArrayDig, 'Filter is empty and all rows are shown');\n\n  filters(0).inputFilter('invalid input');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['No records to show'], 'All rows are filtered out and proper message is shown');\n  assert.equal(rows(0).getCellColspans(), columns.length, 'cell with message has correct colspan');\n\n  assert.equal(filters(0).inputPlaceholder, 'custom placeholder', 'Placeholder is correct');\n\n  this.set('useFilteringByColumns', false);\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), oneTenArrayDig, 'Filtering by columns is ignored');\n  assert.equal($('thead input').length, 0, 'Columns filters are hidden');\n\n});\n\ntest('filtering by columns (ignore case ON)', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  this.setProperties({\n    filteringIgnoreCase: true,\n    useFilteringByColumns: true,\n    columns,\n    data: generateContent(10, 1)\n  });\n\n  this.render(hbs`{{models-table filteringIgnoreCase=filteringIgnoreCase columns=columns data=data useFilteringByColumns=useFilteringByColumns}}`);\n  filters(1).inputFilter('One');\n  assert.deepEqual(rows(0).cells().mapBy('content'), ['1', 'one'], 'Content is filtered correctly');\n\n  filters(1).inputFilter('');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), oneTenArrayDig, 'Filter is empty and all rows are shown');\n\n  filters(1).inputFilter('invalid input');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['No records to show'], 'All rows are filtered out and proper message is shown');\n  assert.equal(rows(0).getCellColspans(), columns.length, 'cell with message has correct colspan');\n\n  filters(1).inputFilter('');\n\n  filters(1).inputFilter('One');\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), ['one'], 'Content is filtered correctly when sorting is not done');\n\n  this.set('useFilteringByColumns', false);\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), oneTenArrayDig, 'Filtering by columns is ignored');\n  assert.equal(filters().count, 0, 'Columns filters are hidden');\n\n});\n\ntest('filtering by columns with custom functions', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[0].filterFunction = signFilter;\n\n  this.setProperties({\n    useFilteringByColumns: true,\n    columns,\n    data: generateContent(10, 1)\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data useFilteringByColumns=useFilteringByColumns}}`);\n  filters(0).inputFilter('=1');\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['1'], `Content is filtered correctly (with '=1')`);\n\n  filters(0).inputFilter('>5');\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['6', '7', '8', '9', '10'], `Content is filtered correctly (with '>5')`);\n\n  filters(0).inputFilter('<6');\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['1', '2', '3', '4', '5'], `Content is filtered correctly (with '<6')`);\n\n});\n\ntest('filtering by columns with custom functions and predefined filter options', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[0].filterFunction = signFilter;\n  columns[0].filterWithSelect = true;\n  columns[0].predefinedFilterOptions = ['=1', '>5', '<6'];\n\n  this.setProperties({\n    useFilteringByColumns: true,\n    columns,\n    data: generateContent(10, 1)\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data useFilteringByColumns=useFilteringByColumns}}`);\n  filters(0).selectFilter('=1');\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['1'], `Content is filtered correctly (with '=1')`);\n\n  filters(0).selectFilter('>5');\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['6', '7', '8', '9', '10'], `Content is filtered correctly (with '>5')`);\n\n  filters(0).selectFilter('<6');\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['1', '2', '3', '4', '5'], `Content is filtered correctly (with '<6')`);\n\n});\n\ntest('filtering with filterWithSelect (without predefinedFilterOptions)', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[1].filterWithSelect = true;\n  const data = generateContent(10, 1);\n  data[data.length - 1].someWord = '';\n  this.setProperties({\n    columns,\n    data\n  });\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n\n  assert.equal(filters(1).selectOptions.length, 10, 'Empty data-value was excluded');\n\n  assert.deepEqual(filters(1).selectOptions, ['', ...data.mapBy('someWord').slice(0, -1)], 'Options for select are valid');\n\n  filters(1).selectFilter('one');\n\n  assert.equal(rows().count, 1, 'Only one row exist after filtering');\n\n  this.set('data.0.someWord', 'not a number');\n\n  assert.equal(filters(1).selectValue, '', 'Filter is reverted to the default value');\n\n  filters(1).selectFilter('');\n\n  assert.equal(rows().count, 10, 'All rows are shown after clear filter');\n\n});\n\ntest('filtering with filterWithSelect (without predefinedFilterOptions), `sortFilterOptions` is true', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[1].filterWithSelect = true;\n  columns[1].sortFilterOptions = true;\n  const data = generateContent(10, 1);\n  data[data.length - 1].someWord = '';\n  const words = data.mapBy('someWord').sort();\n  this.setProperties({\n    columns,\n    data\n  });\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n\n  assert.deepEqual(filters(1).selectOptions, words, 'Options for select are valid');\n\n  filters(1).selectFilter('one');\n\n  assert.equal(rows().count, 1, 'Only one row exist after filtering');\n\n});\n\ntest('filtering with filterWithSelect (without predefinedFilterOptions), sort by property with boolean values', function (assert) {\n\n  const columns = generateColumns(['index', 'rand']);\n  columns[1].filterWithSelect = true;\n  const data = generateContent(10, 1);\n  this.setProperties({\n    columns,\n    data\n  });\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n\n  assert.equal(rows().count, 10, '10 rows exist before filtering');\n\n  filters(1).selectFilter('true');\n  assert.equal(rows().count, 5, '5 rows exist after filtering');\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), ['true', 'true', 'true', 'true', 'true'], 'valid rows are shown');\n\n  filters(1).selectFilter('false');\n  assert.equal(rows().count, 5, '5 rows exist after filtering (2)');\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), ['false', 'false', 'false', 'false', 'false'], 'valid rows are shown (2)');\n\n});\n\ntest('filtering with filterWithSelect (with predefinedFilterOptions as primitives)', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[1].filterWithSelect = true;\n  columns[1].predefinedFilterOptions = ['one', 'two'];\n  const data = generateContent(10, 1);\n\n  this.setProperties({\n    columns,\n    data\n  });\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n\n  assert.deepEqual(filters(1).selectOptions, ['', 'one', 'two'], 'Options for select are valid');\n\n  filters(1).selectFilter('one');\n  assert.equal(filters(1).selectValue, 'one', 'Proper option is selected');\n  assert.equal(rows().count, 1, 'Only one row exist after filtering');\n\n  this.set('data', generateContent(9, 2));\n\n  assert.equal(filters(1).selectValue, 'one', 'Filter is not reverted to the default value');\n  assert.deepEqual(filters(1).selectOptions, ['', 'one', 'two'], 'Options for select are valid');\n\n  filters(1).selectFilter('');\n\n  assert.equal(rows().count, 9, 'All rows are shown after clear filter');\n\n});\n\ntest('filtering with filterWithSelect (with predefinedFilterOptions as objects)', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[1].filterWithSelect = true;\n  columns[1].predefinedFilterOptions = [{label: '1', value: 'one'}, {label: '2', value: 'two'}];\n  const data = generateContent(10, 1);\n\n  this.setProperties({\n    columns,\n    data\n  });\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n\n  assert.deepEqual(filters(1).selectOptions, ['', '1', '2'], 'Options for select are valid');\n\n  filters(1).selectFilter('one');\n  assert.equal(filters(1).selectValue, 'one', 'Proper option is selected');\n  assert.equal(rows().count, 1, 'Only one row exist after filtering');\n\n  this.set('data', generateContent(9, 2));\n\n  assert.equal(filters(1).selectValue, 'one', 'Filter is not reverted to the default value');\n  assert.deepEqual(filters(1).selectOptions, ['', '1', '2'], 'Options for select are valid');\n\n  filters(1).selectFilter('');\n\n  assert.equal(rows().count, 9, 'All rows are shown after clear filter');\n\n});\n\ntest('filtering with filterWithSelect (with predefinedFilterOptions as empty array)', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[1].filterWithSelect = true;\n  columns[1].predefinedFilterOptions = [];\n  const data = generateContent(10, 1);\n\n  this.setProperties({\n    columns,\n    data\n  });\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n\n  assert.notOk(filters(1).selectFilterExists, 'Select-box for column with `filterWithSelect` does not exist if empty predefinedFilterOptions are given');\n});\n\ntest('filtering with `filteredBy`', function (assert) {\n\n  const columns = generateColumns(['index', 'index']);\n  delete columns[0].propertyName;\n  columns[0].filteredBy = 'index';\n  this.setProperties({\n    columns,\n    data: generateContent(10, 1),\n    useFilteringByColumns: true\n  });\n  this.render(hbs`{{models-table data=data columns=columns useFilteringByColumns=useFilteringByColumns}}`);\n\n  filters(1).inputFilter('1');\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), ['1', '10'], 'Content is filtered correctly');\n\n  filters(1).inputFilter('');\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), oneTenArrayDig, 'Filter is empty and all rows are shown');\n\n});\n\ntest('`filteredBy` hash higher priority than `propertyName`', function (assert) {\n\n  const columns = generateColumns(['someWord']);\n  columns[0].filteredBy = 'index';\n  this.setProperties({\n    columns,\n    data: generateContent(10, 1)\n  });\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n  ModelsTableBs.doGlobalFilter('2');\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['two'], 'Content is filtered correctly (global filter)');\n\n  ModelsTableBs.doGlobalFilter('');\n  filters(0).inputFilter('2');\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['two'], 'Content is filtered correctly (filter by column)');\n\n});\n\ntest('icons for clearing filters exist', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[1].filterWithSelect = true;\n  this.setProperties({\n    columns,\n    data: generateContent(10, 1)\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n  assert.notOk(ModelsTableBs.clearAllFiltersVisible, '`Clear all filters` icon does not exist');\n\n  ModelsTableBs.doGlobalFilter(2);\n  assert.ok(ModelsTableBs.clearGlobalFilterExists, '`Clear global filter` icon exists');\n  assert.ok(ModelsTableBs.clearAllFiltersVisible, '`Clear all filters` icon exists');\n  ModelsTableBs.doGlobalFilter('');\n  assert.notOk(ModelsTableBs.clearGlobalFilterExists, '`Clear global filter` icon does not exist');\n  assert.notOk(ModelsTableBs.clearAllFiltersVisible, '`Clear all filters` icon does not exist');\n\n  filters(0).inputFilter(1);\n  assert.ok(filters(0).clearFilterExists, '`Clear first column filter` icon exists');\n  assert.ok(ModelsTableBs.clearAllFiltersVisible, '`Clear all filters` icon exists');\n  filters(0).inputFilter('');\n  assert.notOk(filters(0).clearFilterExists, '`Clear first column filter` icon does not exist');\n  assert.notOk(ModelsTableBs.clearAllFiltersVisible, '`Clear all filters` icon does not exist');\n\n  filters(1).selectFilter('one');\n  assert.ok(filters(1).clearFilterExists, '`Clear second column select filter` icon exists');\n  assert.ok(ModelsTableBs.clearAllFiltersVisible, '`Clear all filters` icon exists');\n  filters(1).selectFilter('');\n  assert.notOk(filters(1).clearFilterExists, '`Clear second column select filter` icon does not exist');\n  assert.notOk(ModelsTableBs.clearAllFiltersVisible, '`Clear all filters` icon does not exist');\n\n});\n\ntest('clear filters using icons', function (assert) {\n\n  const columns = generateColumns(['index', 'someWord']);\n  columns[1].filterWithSelect = true;\n  const data = generateContent(10, 1);\n  this.setProperties({\n    columns,\n    data\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n\n  ModelsTableBs.doGlobalFilter(2);\n  assert.equal(rows().count, 1, 'Global filter is used');\n  ModelsTableBs.clearGlobalFilter();\n  assert.equal(rows().count, data.length, 'Global filter is clear (1)');\n\n  ModelsTableBs.doGlobalFilter(2);\n  assert.equal(rows().count, 1, 'Global filter is used');\n  ModelsTableBs.clearAllFilters();\n  assert.equal(rows().count, data.length, 'Global filter is clear (2)');\n\n  filters(0).inputFilter(2);\n  assert.equal(rows().count, 1, 'Filter for first column is used');\n  ModelsTableBs.clearAllFilters();\n  assert.equal(rows().count, data.length, 'Filter for first column is clear (1)');\n\n  filters(0).inputFilter(2);\n  assert.equal(rows().count, 1, 'Filter for first column is used');\n  ModelsTableBs.clearAllFilters();\n  assert.equal(rows().count, data.length, 'Filter for first column is clear (2)');\n\n  filters(1).selectFilter('one');\n  assert.equal(rows().count, 1, 'Filter for second column is used');\n  filters(1).clearFilter();\n  assert.equal(rows().count, data.length, 'Filter for second column is clear (1)');\n\n  filters(1).selectFilter('one');\n  assert.equal(rows().count, 1, 'Filter for second column is used');\n  ModelsTableBs.clearAllFilters();\n  assert.equal(rows().count, data.length, 'Filter for second column is clear (2)');\n\n  ModelsTableBs.doGlobalFilter(2);\n  filters(0).inputFilter(2);\n  filters(1).selectFilter('two');\n  assert.equal(rows().count, 1, 'All filters are used, 1 row shown');\n  ModelsTableBs.clearAllFilters();\n  assert.equal(rows().count, data.length, 'All filters are clear');\n\n});\n\ntest('custom messages', function (assert) {\n\n  const messages = O.create({\n    searchLabel: 'Se@rch:',\n    'columns-title': 'ColumnZ',\n    'columns-showAll': 'Show Me All!',\n    'columns-hideAll': 'Hide All!',\n    'columns-restoreDefaults': 'Restore My Columns',\n    tableSummary: 'Now are showing %@ - %@ of %@',\n    allColumnsAreHidden: 'No visible columns, dude!',\n    noDataToShow: 'No data. Sorry, bro...'\n  });\n\n  const messages2 = O.create({\n    searchLabel: 'SEARCH',\n    'columns-title': 'COLUMNS',\n    'columns-showAll': 'SHOW All',\n    'columns-hideAll': 'HIDE ALL',\n    'columns-restoreDefaults': 'RESTORE MY COLUMNS',\n    tableSummary: 'DISPLAY %@ - %@ OF %@',\n    allColumnsAreHidden: 'NO COLUMNS',\n    noDataToShow: 'NO DATA'\n  });\n\n  this.setProperties({\n    columns: generateColumns(['index', 'reversedIndex']),\n    data: generateContent(10, 1),\n    customMessages: messages\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns customMessages=customMessages}}`);\n\n  assert.equal(ModelsTableBs.summary, 'Now are showing 1 - 10 of 10', 'Summary is valid');\n  assert.equal(columnsDropDown().toggleLabel, messages['columns-title'], 'Columns-dropdown title is valid');\n  assert.equal(columnsDropDown(0).label, messages['columns-showAll'], 'Columns-dropdown \"showAll\" is valid');\n  assert.equal(columnsDropDown(1).label, messages['columns-hideAll'], 'Columns-dropdown \"hideAll\" is valid');\n  assert.equal(columnsDropDown(2).label, messages['columns-restoreDefaults'], 'Columns-dropdown \"restoreDefaults\" is valid');\n  assert.equal(ModelsTableBs.globalFilterLabel, messages.searchLabel, 'Global-search label is valid');\n\n  columnsDropDown(1).click();\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), [messages.allColumnsAreHidden], 'Message about all hidden columns is valid');\n\n  columnsDropDown(0).click();\n  ModelsTableBs.doGlobalFilter('invalid string');\n\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), [messages.noDataToShow], 'Message about no data is valid');\n\n  this.set('customMessages', messages2);\n\n  ModelsTableBs.doGlobalFilter('');\n\n  assert.equal(ModelsTableBs.summary, 'DISPLAY 1 - 10 OF 10', 'Summary is valid (2)');\n  assert.equal(columnsDropDown().toggleLabel, messages2['columns-title'], 'Columns-dropdown title is valid (2)');\n  assert.equal(columnsDropDown(0).label, messages2['columns-showAll'], 'Columns-dropdown \"showAll\" is valid (2)');\n  assert.equal(columnsDropDown(1).label, messages2['columns-hideAll'], 'Columns-dropdown \"hideAll\" is valid (2)');\n  assert.equal(columnsDropDown(2).label, messages2['columns-restoreDefaults'], 'Columns-dropdown \"restoreDefaults\" is valid (2)');\n  assert.equal(ModelsTableBs.globalFilterLabel, messages2.searchLabel, 'Global-search label is valid (2)');\n\n  columnsDropDown(1).click();\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), [messages2.allColumnsAreHidden], 'Message about all hidden columns is valid (2)');\n\n  columnsDropDown(0).click();\n  ModelsTableBs.doGlobalFilter('invalid string');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), [messages2.noDataToShow], 'Message about no data is valid (2)');\n\n});\n\ntest('custom icons', function (assert) {\n\n  const customIcons = {\n    'sort-asc': 'sort-asc',\n    'sort-desc': 'sort-desc',\n    'column-visible': 'column-visible',\n    'column-hidden': 'column-hidden',\n    'nav-first': 'nav-first',\n    'nav-prev': 'nav-prev',\n    'nav-next': 'nav-next',\n    'nav-last': 'nav-last'\n  };\n\n  this.setProperties({\n    columns: generateColumns(['index', 'reversedIndex']),\n    data: generateContent(10, 1),\n    themeInstance: BootstrapTheme.extend(customIcons).create()\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns themeInstance=themeInstance}}`);\n  sorting(0).click();\n\n  assert.equal($('.sort-asc').length, 1, 'sort asc 1 column');\n\n  sorting(1).click();\n\n  sorting(1).click();\n  assert.equal($('.sort-asc').length, 1, 'sort asc 1 column');\n  assert.equal($('.sort-desc').length, 1, 'sort desc 1 column');\n\n  assert.equal($('.columns-dropdown li .column-visible').length, 2, 'all columns are visible');\n\n  columnsDropDown(3).click();\n  assert.equal($('.columns-dropdown li .column-visible').length, 1, '1 column is visible');\n  assert.equal($('.columns-dropdown li .column-hidden').length, 1, '1 column is hidden');\n\n  assert.ok($(`.table-nav a:eq(0) span`).hasClass('nav-first'), 'First-button has valid class');\n  assert.ok($(`.table-nav a:eq(1) span`).hasClass('nav-prev'), 'Prev-button has valid class');\n  assert.ok($(`.table-nav a:eq(2) span`).hasClass('nav-next'), 'Next-button has valid class');\n  assert.ok($(`.table-nav a:eq(3) span`).hasClass('nav-last'), 'Last-button has valid class');\n\n});\n\ntest('columns column cell classes', function (assert) {\n\n  const columns = generateColumns(['index', 'reversedIndex']);\n  columns[0].className = 'custom-column-class';\n  this.setProperties({\n    columns,\n    data: generateContent(10, 1)\n  });\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n\n  assert.equal($('tbody .custom-column-class').length, 10, 'Custom column class exists on each column cell');\n\n});\n\ntest('column title auto generation', function (assert) {\n\n  const columns = generateColumns(['index', 'reversedIndex']);\n  columns.setEach('title', null);\n  this.setProperties({\n    columns,\n    data: generateContent(10, 1)\n  });\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n\n  assert.deepEqual(sorting().mapBy('title'), ['Index', 'Reversed index']);\n\n});\n\ntest('`sortedBy` has higher priority than `propertyName`', function (assert) {\n\n  const columns = generateColumns(['someWord', 'index']);\n  columns[0].sortedBy = 'index';\n  this.setProperties({\n    columns,\n    data: generateContent(10, 1)\n  });\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n\n  sorting(1).click();\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), oneTenArrayDig, 'Content is valid (sorting by `index` desc)');\n\n  sorting(1).click();\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), tenOneArrayDig, 'Content is valid (sorting by `index` asc)');\n\n});\n\ntest('sorting (multi `true`)', function (assert) {\n\n  this.setProperties({\n    columns: generateColumns(['index', 'index2']),\n    data: generateContent(10, 1)\n  });\n  this.render(hbs`{{models-table columns=columns data=data}}`);\n  sorting(0).click();\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), oneTenArrayDig, 'Content is valid (sorting 1st column asc)');\n\n  sorting(0).click();\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), tenOneArrayDig, 'Content is valid (sorting 1st column desc)');\n\n  sorting(0).click();\n  sorting(1).click();\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), oneTenArrayDig, 'Content is valid (sorting 1st column asc) - restore defaults');\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), ['1', '1', '2', '2', '3', '3', '4', '4', '5', '5'], 'Content is valid (sorting 2nd column asc) - restore defaults');\n\n  sorting(0).click();\n  sorting(0).click();\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['2', '1', '4', '3', '6', '5', '8', '7', '10', '9'], 'Content is valid (sorting 1st column desc)');\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), ['1', '1', '2', '2', '3', '3', '4', '4', '5', '5'], 'Content is valid (sorting 2nd column asc)');\n\n});\n\ntest('sorting (multi `false`)', function (assert) {\n\n  this.setProperties({\n    columns: generateColumns(['index', 'index2']),\n    data: generateContent(10, 1)\n  });\n  this.render(hbs`{{models-table columns=columns data=data multipleColumnsSorting=false}}`);\n  sorting(0).click();\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), oneTenArrayDig, 'Content is valid (sorting 1st column asc)');\n\n  sorting(0).click();\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), tenOneArrayDig, 'Content is valid (sorting 1st column desc)');\n\n  sorting(0).click();\n  sorting(1).click();\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), oneTenArrayDig, 'Content is valid (sorting 1st column asc) - restore defaults');\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), ['1', '1', '2', '2', '3', '3', '4', '4', '5', '5'], 'Content is valid (sorting 2nd column asc) - restore defaults');\n\n  sorting(0).click();\n  sorting(0).click();\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), tenOneArrayDig, 'Content is valid (sorting 1st column desc)');\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), ['5', '5', '4', '4', '3', '3', '2', '2', '1', '1'], 'Content is valid (sorting 2nd reverted)');\n\n});\n\ntest('column is sorted with `sortedBy` when `propertyName` is not provided', function (assert) {\n\n  const columns = generateColumns(['index', 'index2']);\n  columns[1].sortedBy = 'index';\n  delete columns[1].propertyName;\n  columns[1].component = 'custom-concat';\n\n  this.setProperties({\n    columns,\n    data: generateContent(3, 1).reverse()\n  });\n  this.render(hbs`{{models-table columns=columns data=data multipleColumnsSorting=false}}`);\n\n  sorting(1).click();\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), ['1+3', '2+2', '3+1'], 'Content is sorted by `index`');\n\n});\n\ntest('table is not sorted by first column with `propertyName` or `sortedBy` by default', function (assert) {\n\n  const data = generateContent(10, 1).reverse();\n  const columns = generateColumns(['indexWithHtml', 'index']);\n  delete columns[0].propertyName;\n\n  this.setProperties({\n    data,\n    columns\n  });\n  this.render(hbs`{{models-table data=data columns=columns}}`);\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(1), tenOneArrayDig, 'Content is sorted correctly');\n\n});\n\ntest('sendAction can trigger actions outside the component (from row cell component)', function (assert) {\n\n  assert.expect(1);\n  const columns = generateColumns(['index', 'indexWithHtml']);\n  columns[1].component = 'custom-action';\n\n  this.on('externalAction', function () {\n    assert.ok(true, 'external Action was called!');\n  });\n\n  this.setProperties({\n    data: generateContent(10, 1),\n    columns,\n    action: 'externalAction'\n  });\n  this.render(hbs`{{models-table data=data columns=columns action=action}}`);\n\n  this.$('.action').first().click();\n});\n\ntest('sendAction can trigger actions outside the component (from row expand component)', function (assert) {\n\n  assert.expect(1);\n  let columns = generateColumns(['id']);\n  columns.splice(0, 0, {\n    component: 'expand-toggle',\n    mayBeHidden: false\n  });\n  this.setProperties({\n    columns,\n    expandedRowComponent: 'custom-expand-row-action',\n    data: generateContent(10, 1),\n    externalAction: 'externalAction'\n  });\n\n  this.on('externalAction', function () {\n    assert.ok(true, 'external Action was called!');\n  });\n  this.render(hbs`{{models-table columns=columns data=data expandedRowComponent=expandedRowComponent externalAction=externalAction}}`);\n  rows(0).expand();\n  this.$('.action').first().click();\n});\n\ntest('sendAction can trigger actions outside the component (from sort cell component)', function (assert) {\n\n  assert.expect(1);\n  const columns = generateColumns(['index', 'indexWithHtml']);\n  columns[0].componentForSortCell = 'custom-sort-cell-action';\n\n  this.on('externalAction', function () {\n    assert.ok(true, 'external Action was called!');\n  });\n\n  this.setProperties({\n    data: generateContent(10, 1),\n    columns,\n    externalAction: 'externalAction'\n  });\n  this.render(hbs`{{models-table data=data columns=columns externalAction=externalAction}}`);\n\n  this.$('.action').first().click();\n});\n\ntest('sendAction can trigger actions outside the component (from filter cell component)', function (assert) {\n\n  assert.expect(1);\n  const columns = generateColumns(['index', 'indexWithHtml']);\n  columns[0].componentForFilterCell = 'custom-filter-cell-action';\n\n  this.on('externalAction', function () {\n    assert.ok(true, 'external Action was called!');\n  });\n\n  this.setProperties({\n    data: generateContent(10, 1),\n    columns,\n    externalAction: 'externalAction'\n  });\n  this.render(hbs`{{models-table data=data columns=columns externalAction=externalAction}}`);\n\n  this.$('.action').first().click();\n});\n\ntest('visiblePageNumbers', function (assert) {\n\n  this.setProperties({\n    data: generateContent(10, 1),\n    columns: generateColumns(['index']),\n    currentPageNumber: 1,\n    useNumericPagination: true,\n    pageSize: 1\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns currentPageNumber=currentPageNumber pageSize=pageSize useNumericPagination=useNumericPagination}}`);\n\n  A([\n    {\n      currentPageNumber: 1,\n      visiblePageNumbers: [{label:1,isLink:true,isActive:true},{label:2,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:10,isLink:true,isActive:false}]\n    },\n    {\n      currentPageNumber: 2,\n      visiblePageNumbers: [{label:1,isLink:true,isActive:false},{label:2,isLink:true,isActive:true},{label:3,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:10,isLink:true,isActive:false}]\n    },\n    {\n      currentPageNumber: 3,\n      visiblePageNumbers: [{label:1,isLink:true,isActive:false},{label:2,isLink:true,isActive:false},{label:3,isLink:true,isActive:true},{label:4,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:10,isLink:true,isActive:false}]\n    },\n    {\n      currentPageNumber: 4,\n      visiblePageNumbers: [{label:1,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:3,isLink:true,isActive:false},{label:4,isLink:true,isActive:true},{label:5,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:10,isLink:true,isActive:false}]\n    },\n    {\n      currentPageNumber: 5,\n      visiblePageNumbers: [{label:1,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:4,isLink:true,isActive:false},{label:5,isLink:true,isActive:true},{label:6,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:10,isLink:true,isActive:false}]\n    },\n    {\n      currentPageNumber: 6,\n      visiblePageNumbers: [{label:1,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:5,isLink:true,isActive:false},{label:6,isLink:true,isActive:true},{label:7,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:10,isLink:true,isActive:false}]\n    },\n    {\n      currentPageNumber: 7,\n      visiblePageNumbers: [{label:1,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:6,isLink:true,isActive:false},{label:7,isLink:true,isActive:true},{label:8,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:10,isLink:true,isActive:false}]\n    },\n    {\n      currentPageNumber: 8,\n      visiblePageNumbers: [{label:1,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:7,isLink:true,isActive:false},{label:8,isLink:true,isActive:true},{label:9,isLink:true,isActive:false},{label:10,isLink:true,isActive:false}]\n    },\n    {\n      currentPageNumber: 9,\n      visiblePageNumbers: [{label:1,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:8,isLink:true,isActive:false},{label:9,isLink:true,isActive:true},{label:10,isLink:true,isActive:false}]\n    },\n    {\n      currentPageNumber: 10,\n      visiblePageNumbers: [{label:1,isLink:true,isActive:false},{label:'...',isLink:false,isActive:false},{label:9,isLink:true,isActive:false},{label:10,isLink:true,isActive:true}]\n    }\n  ]).forEach(test => {\n    this.set('currentPageNumber', test.currentPageNumber);\n    assert.deepEqual(navigation.navigationButtons, A(test.visiblePageNumbers).mapBy('label').map(c => `${c}`), `10 pages, active is ${test.currentPageNumber}`);\n  }, this);\n\n  this.set('data', generateContent(10, 1));\n  this.set('pageSize', 10);\n\n  assert.deepEqual(navigation.navigationButtons, ['1'], 'Only 1 page');\n\n});\n\ntest('event on user interaction (filtering by column)', function (assert) {\n\n  this.setProperties({\n    columns: generateColumns(['index', 'someWord']),\n    data: generateContent(10, 1),\n    displayDataChangedAction: 'displayDataChanged'\n  });\n\n  this.on('displayDataChanged', function () {\n    assert.ok(true, '`displayDataChanged`-action was called!');\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data displayDataChangedAction=displayDataChangedAction sendDisplayDataChangedAction=true}}`);\n  filters(1).inputFilter('One');\n\n});\n\ntest('event on user interaction (global filtering)', function (assert) {\n\n  this.setProperties({\n    columns: generateColumns(['index', 'someWord']),\n    data: generateContent(10, 1),\n    displayDataChangedAction: 'displayDataChanged'\n  });\n\n  this.on('displayDataChanged', function () {\n    assert.ok(true, '`displayDataChanged`-action was called!');\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data displayDataChangedAction=displayDataChangedAction sendDisplayDataChangedAction=true}}`);\n  ModelsTableBs.doGlobalFilter('One');\n});\n\ntest('event on user interaction (sorting)', function (assert) {\n\n  this.setProperties({\n    columns: generateColumns(['index', 'someWord']),\n    data: generateContent(10, 1),\n    displayDataChangedAction: 'displayDataChanged',\n    sendDisplayDataChangedAction: true\n  });\n\n  this.on('displayDataChanged', function () {\n    assert.ok(true, '`displayDataChanged`-action was called!');\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data displayDataChangedAction=displayDataChangedAction sendDisplayDataChangedAction=sendDisplayDataChangedAction}}`);\n  sorting(0).click();\n});\n\ntest('event on user interaction (expanding rows)', function (assert) {\n\n  const columns = generateColumns(['id']);\n  columns.splice(0, 0, {\n    component: 'expand-toggle',\n    mayBeHidden: false\n  });\n  this.setProperties({\n    columns,\n    data: generateContent(30, 1),\n    displayDataChangedAction: 'displayDataChanged',\n    sendDisplayDataChangedAction: true,\n    expandedRowComponent: 'expanded-row'\n  });\n\n  this.on('displayDataChanged', function () {\n    assert.ok(true, '`displayDataChanged`-action was called!');\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data displayDataChangedAction=displayDataChangedAction sendDisplayDataChangedAction=sendDisplayDataChangedAction expandedRowComponent=expandedRowComponent}}`);\n  rows(0).expand();\n\n});\n\ntest('event on user interaction (selecting rows)', function (assert) {\n\n  this.setProperties({\n    columns: generateColumns(['id']),\n    data: generateContent(30, 1),\n    displayDataChangedAction: 'displayDataChanged',\n    sendDisplayDataChangedAction: true\n  });\n\n  this.on('displayDataChanged', function () {\n    assert.ok(true, '`displayDataChanged`-action was called!');\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data displayDataChangedAction=displayDataChangedAction sendDisplayDataChangedAction=sendDisplayDataChangedAction}}`);\n  rows(0).click();\n\n});\n\ntest('event on user interaction (clear all filters)', function (assert) {\n\n  const calls = [\n    // after render\n    {\n      filterString: '',\n      columnFilters: {}\n    },\n    // after filter by first column\n    {\n      filterString: '',\n      columnFilters: {id: '1'}\n    },\n    // after global filter\n    {\n      filterString: '1',\n      columnFilters: {id: '1'}\n    },\n    // after clear all filters\n    {\n      filterString: '',\n      columnFilters: {}\n    }\n  ];\n  let indx = 0;\n  this.setProperties({\n    columns: generateColumns(['id']),\n    data: generateContent(30, 1),\n    displayDataChangedAction: 'displayDataChanged',\n    sendDisplayDataChangedAction: true\n  });\n\n  this.on('displayDataChanged', function (settings) {\n    const call = calls[indx];\n    assert.equal(call.filterString, settings.filterString, `#${indx + 1}. filterString`);\n    assert.deepEqual(call.columnFilters, settings.columnFilters, `#${indx + 1}. columnFilters`);\n    indx++;\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data displayDataChangedAction=displayDataChangedAction sendDisplayDataChangedAction=sendDisplayDataChangedAction expandedRowTemplate=expandedRowTemplate}}`);\n  filters(0).inputFilter(1);\n  ModelsTableBs.doGlobalFilter(1);\n  ModelsTableBs.clearAllFilters();\n});\n\ntest('show first page if for some reasons there is no content for current page, but table data exists', function (assert) {\n\n  assert.expect(1);\n\n  const data = generateContent(11, 1);\n  const columns = generateColumns(['index', 'indexWithHtml']);\n  columns[1].component = 'delete-row';\n  const self = this;\n  this.setProperties({\n    data,\n    columns\n  });\n  this.on('deleteRecord', function (record) {\n    self.set('data', data.without(record));\n  });\n  this.render(hbs`{{models-table data=data columns=columns delete='deleteRecord'}}`);\n  // move to the 2nd page and delete 1 row there\n  navigation.goToNextPage();\n  this.$('td button').first().click();\n  assert.equal(ModelsTableBs.summary, 'Show 1 - 10 of 10', 'First page is shown');\n});\n\ntest('row deleted in the middle page', function (assert) {\n\n  assert.expect(1);\n\n  const data = generateContent(31, 1);\n  const columns = generateColumns(['index', 'indexWithHtml']);\n  columns[1].component = 'delete-row';\n  const self = this;\n  this.setProperties({\n    data,\n    columns\n  });\n  this.on('deleteRecord', function (record) {\n    self.set('data', data.without(record));\n  });\n  this.render(hbs`{{models-table data=data columns=columns delete='deleteRecord'}}`);\n  // move to the 2nd page and delete 1 row there\n  navigation.goToNextPage();\n  this.$('td button').first().click();\n  assert.equal(ModelsTableBs.summary, 'Show 11 - 20 of 30', 'Second page is shown');\n});\n\ntest('updateable columns (disabled)', function (assert) {\n\n  const columns1 = generateColumns(['index', 'someWord']);\n  const columns2 = generateColumns(['index', 'index2', 'someWord']);\n\n  this.setProperties({\n    columns: columns1,\n    data: generateContent(10, 1),\n    columnsAreUpdateable: false\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data columnsAreUpdateable=columnsAreUpdateable}}`);\n  filters(0).inputFilter('1');\n  sorting(0).click();\n  assert.deepEqual(sorting().mapBy('title'), ['index', 'someWord'], 'two columns are shown');\n  assert.deepEqual(columnsDropDown().mapBy('label'), ['Show All', 'Hide All', 'Restore Defaults', 'index', 'someWord'], 'two columns are in columns dropdown');\n\n  this.set('columns', columns2);\n  assert.deepEqual(sorting().mapBy('title'), ['index', 'someWord'], 'columns are not updated');\n  assert.deepEqual(columnsDropDown().mapBy('label'), ['Show All', 'Hide All', 'Restore Defaults', 'index', 'someWord'], 'columns dropdown is not updated');\n  assert.equal(filters(0).inputValue, '1', 'column filter was not dropped');\n  assert.ok(sorting(0).isSorted, 'column sorting was not dropped');\n});\n\ntest('updateable columns (enabled)', function (assert) {\n\n  const columns1 = generateColumns(['index', 'someWord']);\n  const columns2 = generateColumns(['index', 'index2', 'someWord']);\n\n  this.setProperties({\n    columns: columns1,\n    data: generateContent(10, 1),\n    columnsAreUpdateable: true\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data columnsAreUpdateable=columnsAreUpdateable}}`);\n  assert.deepEqual(sorting().mapBy('title'), ['index', 'someWord'], 'two columns are shown');\n  assert.deepEqual(columnsDropDown().mapBy('label'), ['Show All', 'Hide All', 'Restore Defaults', 'index', 'someWord'], 'two columns are in columns dropdown');\n  filters(0).inputFilter('1');\n  sorting(0).click();\n\n  this.set('columns', columns2);\n  assert.deepEqual(sorting().mapBy('title'), ['index', 'index2', 'someWord'], 'columns are updated');\n  assert.deepEqual(columnsDropDown().mapBy('label'), ['Show All', 'Hide All', 'Restore Defaults', 'index', 'index2', 'someWord'], 'columns dropdown is updated');\n  assert.equal(filters(0).inputValue, '', 'column filter was dropped');\n\n});\n\ntest('filtering with `doFilteringByHiddenColumns` = false', function (assert) {\n\n  this.setProperties({\n    columns: generateColumns(['index', 'someWord']),\n    data: generateContent(10, 1),\n    doFilteringByHiddenColumns: false\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data doFilteringByHiddenColumns=doFilteringByHiddenColumns}}`);\n\n  columnsDropDown(4).click();\n  ModelsTableBs.doGlobalFilter('one');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['No records to show'], 'Content is not changed');\n\n  this.set('doFilteringByHiddenColumns', true);\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['No records to show'], 'Content is not changed after `doFilteringByHiddenColumns` updating');\n\n  ModelsTableBs.doGlobalFilter('');\n  ModelsTableBs.doGlobalFilter('one');\n\n  assert.deepEqual(ModelsTableBs.getColumnCells(0), ['1'], 'Content is filtered');\n\n});\n\ntest('grouped headers', function (assert) {\n\n  this.setProperties({\n    columns: generateColumns(['index', 'index2', 'reversedIndex', 'indexWithHtml', 'someWord']),\n    data: generateContent(10, 1),\n    groupedHeaders: [\n      [{title: 'BigTitle', colspan: 5}],\n      [{title: 'SubTitle1', colspan: 2}, {title: 'SubTitle2', colspan: 3}]\n    ]\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data groupedHeaders=groupedHeaders}}`);\n\n  assert.deepEqual(headers(0).cells, ['BigTitle']);\n  assert.deepEqual(headers(0).colspans, ['5']);\n\n  assert.deepEqual(headers(1).cells, ['SubTitle1', 'SubTitle2']);\n  assert.deepEqual(headers(1).colspans, ['2', '3']);\n\n});\n\ntest('expandable rows (multipleExpand = true)', function (assert) {\n\n  const columns = generateColumns(['id']);\n  columns.splice(0, 0, {\n    component: 'expand-toggle',\n    mayBeHidden: false\n  });\n  this.setProperties({\n    columns,\n    expandedRowComponent: 'expanded-row',\n    data: generateContent(30, 1)\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data expandedRowComponent=expandedRowComponent multipleExpand=true}}`);\n\n  assert.equal(ModelsTableBs.collapseRowButtons, 0, 'All rows are collapsed by default');\n\n  rows(0).expand();\n  assert.ok(rows(0).expanded, 'First row is expanded');\n  assert.equal($('.expand-0').length, 1, 'Expanded row content exists');\n  assert.equal($('.expand-0 .id').length, 1, 'Expanded row content is valid');\n\n  rows(1).expand();\n  assert.ok(rows(0).expanded, 'First row is still expanded');\n  assert.ok(rows(1).expanded, 'Second row is expanded');\n\n  rows(0).collapse();\n  assert.ok(rows(0).collapsed, 'First row is collapsed');\n  assert.ok(rows(1).expanded, 'Second row is still expanded');\n\n  rows(1).collapse();\n  assert.ok(rows(1).collapsed, 'Second row is collapsed');\n\n  rows(0).expand();\n  navigation.goToNextPage();\n  assert.ok(rows(0).collapsed, 'First row on the second page is collapsed');\n\n});\n\ntest('expandable rows (multipleExpand = true, expand all rows)', function (assert) {\n\n  const columns = generateColumns(['id']);\n  columns.splice(0, 0, {\n    component: 'expand-toggle',\n    componentForFilterCell: 'expand-all-toggle',\n    mayBeHidden: false\n  });\n  this.setProperties({\n    columns,\n    expandedRowComponent: 'expanded-row',\n    data: generateContent(30, 1)\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data expandedRowComponent=expandedRowComponent multipleExpand=true}}`);\n  assert.equal(ModelsTableBs.collapseRowButtons, 0, 'All rows are collapsed by default');\n\n  ModelsTableBs.expandAllRows();\n  assert.equal(rows().filterBy('expanded').length, 10, 'All rows are expanded');\n  assert.deepEqual(rowExpands().mapBy('id'), oneTenArrayDig, 'Expanded rows content is valid');\n\n  ModelsTableBs.collapseAllRows();\n  assert.equal(rows().filterBy('expanded').length, 0, 'All rows are collapsed');\n\n  ModelsTableBs.expandAllRows();\n  navigation.goToNextPage();\n  assert.equal(rows().filterBy('expanded').length, 0, 'All rows on the second page are collapsed');\n\n});\n\ntest('expandable rows (multipleExpand = false)', function (assert) {\n\n  let columns = generateColumns(['id']);\n  columns.splice(0, 0, {\n    component: 'expand-toggle',\n    mayBeHidden: false\n  });\n  this.setProperties({\n    columns,\n    expandedRowComponent: 'expanded-row',\n    data: generateContent(30, 1)\n  });\n\n  this.render(hbs`{{models-table columns=columns data=data expandedRowComponent=expandedRowComponent multipleExpand=false}}`);\n\n  assert.equal(ModelsTableBs.collapseRowButtons, 0, 'All rows are collapsed by default');\n\n  rows(0).expand();\n  assert.ok(rows(0).expanded, 'First row is expanded');\n  assert.equal(rowExpands(0).id, '1', 'Expanded row content is valid');\n\n  rows(1).expand();\n  assert.ok(rows(0).collapsed, 'First row is collapsed');\n  assert.ok(rows(1).expanded, 'Second row is expanded');\n\n  rows(1).collapse();\n  assert.ok(rows(1).collapsed, 'Second row is collapsed');\n\n  rows(0).expand();\n  navigation.goToNextPage();\n  assert.ok(rows(0).collapsed, 'First row on the second page is collapsed');\n\n});\n\ntest('selectable rows (multipleSelect = true)', function (assert) {\n\n  this.setProperties({\n    data: generateContent(30, 1),\n    columns: generateColumns(['id'])\n  });\n  this.render(hbs`{{models-table data=data column=columns multipleSelect=true}}`);\n\n  assert.equal(rows().filterBy('selected').length, 0, 'No selected rows by default');\n\n  rows(0).click();\n  assert.ok(rows(0).selected, 'First row is selected');\n\n  rows(1).click();\n  assert.ok(rows(0).selected, 'First row is still selected');\n  assert.ok(rows(1).selected, 'Second row is selected');\n\n  rows(0).click();\n  assert.notOk(rows(0).selected, 'First row is not selected');\n  assert.ok(rows(1).selected, 'Second row is selected');\n\n  rows(1).click();\n  assert.notOk(rows(0).selected, 'First row still is not selected');\n  assert.notOk(rows(1).selected, 'Second row is not selected');\n\n});\n\ntest('selectable rows (multipleSelect = false)', function (assert) {\n\n  this.setProperties({\n    data: generateContent(30, 1),\n    columns: generateColumns(['id'])\n  });\n  this.render(hbs`{{models-table data=data column=columns multipleSelect=false}}`);\n\n  assert.equal(rows().filterBy('selected').length, 0, 'No selected rows by default');\n\n  rows(0).click();\n  assert.ok(rows(0).selected, 'First row is selected');\n\n  rows(1).click();\n  assert.notOk(rows(0).selected, 'First row is not selected');\n  assert.ok(rows(1).selected, 'Second row is selected');\n\n  rows(0).click();\n  assert.ok(rows(0).selected, 'First row is selected');\n  assert.notOk(rows(1).selected, 'Second row is not selected');\n\n  rows(1).click();\n  assert.notOk(rows(0).selected, 'First row is not selected');\n  assert.ok(rows(1).selected, 'Second row is selected');\n\n});\n\ntest('row-expand should trigger select/deselect row', function (assert) {\n\n  let columns = generateColumns(['index']);\n  columns = [{\n    component: 'expand-toggle',\n    mayBeHidden: false\n  }, ...columns];\n  this.setProperties({\n    columns,\n    expandedRowComponent: 'expanded-row',\n    data: generateContent(30, 1)\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns expandedRowComponent=expandedRowComponent}}`);\n\n  rows(0).expand();\n  rows(0).click();\n  assert.ok(rows(0).expanded, 'First row is expanded');\n  assert.ok(rowExpands(0).selected, 'First row expand is selected');\n  assert.ok(rows(0).selected, 'First row is selected');\n\n  rowExpands(0).click();\n  assert.notOk(rows(0).selected, 'First row is not selected');\n  assert.notOk(rowExpands(0).selected, 'First row expand is not selected');\n\n  rowExpands(0).click();\n  assert.ok(rows(0).selected, 'First row is selected');\n  assert.ok(rowExpands(0).selected, 'First row expand is selected');\n\n});\n\ntest('rows may be preselected with `preselectedItems`', function (assert) {\n  const data = generateContent(30, 1);\n  this.setProperties({\n    columns: generateColumns(['index1', 'index2']),\n    data,\n    preselectedItems: data.filter((itemn, index) => index % 2 === 0)\n  });\n\n  this.render(hbs`{{models-table data=data columns=columns preselectedItems=preselectedItems}}`);\n\n  assert.equal(rows().filterBy('selected').length, 5, 'Rows are initially selected correctly');\n\n  rows(1).click();\n  assert.equal(rows().filterBy('selected').length, 6, 'One more row become selected');\n\n  rows(0).click();\n  assert.equal(rows().filterBy('selected').length, 5, 'One row become deselected');\n});\n\ntest('columns column contains original definition as a nested property', function (assert) {\n\n  const columns = generateColumns(['index1', 'index2']);\n  columns[0].componentForSortCell = 'custom-sort-cell';\n  columns[0].CustomColumString = 'custom-column-string';\n  columns[0].CustomColumObject = { name: 'custom-column-object' };\n  columns[0].CustomColumBool = true;\n  columns[0].CustomColumNumber = 1;\n\n  this.setProperties({\n    columns,\n    data: generateContent(10, 1)\n  });\n  this.render(hbs`{{models-table columns=columns data=data multipleColumnsSorting=false}}`);\n\n  assert.deepEqual(sorting().mapBy('title'), ['custom-column-string|custom-column-object|true|1', 'index2'],\n    'Custom column properties present in originalDefinition property in processedColumns');\n});\n\ntest('#context-components render custom simple pagination', function (assert) {\n\n  this.set('data', generateContent(30, 1));\n\n  this.render(hbs`\n    {{#models-table data=data as |c|}}\n      {{c.table}}\n      {{#c.footer as |f|}}\n        {{f.summary}}\n        {{f.size-select}}\n        {{#f.pagination-simple}}\n          <a href=\"#\" {{action \"gotoFirst\"}} class={{gotoBackEnabled:enabled:disabled}}>F</a>&nbsp;\n          <a href=\"#\" {{action \"gotoPrev\"}} class={{gotoBackEnabled:enabled:disabled}}>P</a>&nbsp;\n          <a href=\"#\" {{action \"gotoNext\"}} class={{gotoForwardEnabled:enabled:disabled}}>N</a>&nbsp;\n          <a href=\"#\" {{action \"gotoLast\"}} class={{gotoForwardEnabled:enabled:disabled}}>L</a>\n        {{/f.pagination-simple}}\n      {{/c.footer}}\n    {{/models-table}}\n  `);\n  assert.equal(navigation.text, 'F P N L', 'Custom labels are used');\n\n});\n\ntest('#context-components sendAction from row cell component ', function(assert) {\n\n  assert.expect(1);\n  const columns = generateColumns(['index']);\n  columns[0].component = 'custom-action';\n\n  this.on('externalAction', function () {\n    assert.ok(true, 'external Action was called!');\n  });\n\n  this.setProperties({\n    data: generateContent(10, 1),\n    columns,\n    action: 'externalAction'\n  });\n  this.render(hbs`\n    {{#models-table data=data columns=columns action=action as |c|}}\n      {{#c.table as |table|}}\n        {{#table.body as |body|}}\n          {{#each body.visibleContent as |record index|}}\n            {{#body.row record=record index=index as |row|}}\n             {{#each body.visibleProcessedColumns as |column|}}\n                {{#row.cell as |c|}}\n                  {{custom-action record=c.record sendAction=c.sendAction}}\n                {{/row.cell}}\n              {{/each}}\n            {{/body.row}}\n          {{/each}}\n        {{/table.body}}\n      {{/c.table}}\n    {{/models-table}}\n    `);\n  this.$('.action').first().click();\n});\n\ntest('#context-components sendAction from row expand component ', function(assert) {\n\n  assert.expect(1);\n  const columns = generateColumns(['index']);\n  columns.splice(0, 0, {\n    component: 'expand-toggle',\n    mayBeHidden: false\n  });\n  this.on('externalAction', function () {\n    assert.ok(true, 'external Action was called!');\n  });\n\n  this.setProperties({\n    data: generateContent(10, 1),\n    columns,\n    action: 'externalAction'\n  });\n  this.render(hbs`\n    {{#models-table data=data columns=columns action=action as |c|}}\n      {{#c.table as |table|}}\n        {{#table.body as |body|}}\n          {{#each body.visibleContent as |record index|}}\n            {{body.row record=record index=index}}\n            {{#if (exists-in body.expandedRowIndexes index)}}\n              {{#body.row-expand record=record index=index as |re|}}\n                <div class=\"action\" {{action re.sendAction \"action\" re.record}}>{{re.record.index}}</div>\n              {{/body.row-expand}}\n            {{/if}}\n          {{/each}}\n        {{/table.body}}\n      {{/c.table}}\n    {{/models-table}}\n    `);\n  rows(0).expand();\n  this.$('.action').first().click();\n});\n\ntest('#context-components sendAction from sort cell ', function(assert) {\n\n  assert.expect(1);\n  const columns = generateColumns(['index']);\n\n  this.on('externalAction', function () {\n    assert.ok(true, 'external Action was called!');\n  });\n\n  this.setProperties({\n    data: generateContent(10, 1),\n    columns,\n    action: 'externalAction'\n  });\n  this.render(hbs`\n    {{#models-table data=data columns=columns action=action as |c|}}\n      {{#c.table as |table|}}\n        {{#table.header as |h|}}\n          {{#h.row-sorting as |rs|}}\n            {{#each rs.processedColumns as |column|}}\n              <td>{{column.title}}\n              <div class=\"action\" {{action rs.sendAction \"action\" column}}></div></td>\n            {{/each}}\n          {{/h.row-sorting}}\n        {{/table.header}}\n      {{/c.table}}\n    {{/models-table}}\n    `);\n  this.$('.action').first().click();\n});\n\ntest('#context-components sendAction from filter cell', function(assert) {\n\n  assert.expect(1);\n  const columns = generateColumns(['index']);\n\n  this.on('externalAction', function () {\n    assert.ok(true, 'external Action was called!');\n  });\n  this.setProperties({\n    data: generateContent(10, 1),\n    columns,\n    action: 'externalAction'\n  });\n\n  this.render(hbs`\n    {{#models-table data=data columns=columns action=action as |c|}}\n      {{#c.table as |table|}}\n        {{#table.header as |h|}}\n          {{#h.row-filtering as |rf|}}\n            {{#each rf.processedColumns as |column|}}\n              <td>{{column.title}}\n              <div class=\"action\" {{action rf.sendAction \"action\" column}}></div></td>\n            {{/each}}\n          {{/h.row-filtering}}\n        {{/table.header}}\n      {{/c.table}}\n    {{/models-table}}\n    `);\n  this.$('.action').first().click();\n});
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/integration/components/models-table-test.js	(revision cca7c13bfc4d98258e34d628a10ea298679bf05b)
+++ tests/integration/components/models-table-test.js	(revision )
@@ -1458,12 +1458,8 @@
 
 test('event on user interaction (clear all filters)', function (assert) {
 
+  assert.expect(6);
   const calls = [
-    // after render
-    {
-      filterString: '',
-      columnFilters: {}
-    },
     // after filter by first column
     {
       filterString: '',
@@ -1495,7 +1491,7 @@
     indx++;
   });
 
-  this.render(hbs`{{models-table columns=columns data=data displayDataChangedAction=displayDataChangedAction sendDisplayDataChangedAction=sendDisplayDataChangedAction expandedRowTemplate=expandedRowTemplate}}`);
+  this.render(hbs`{{models-table columns=columns data=data displayDataChangedAction=displayDataChangedAction sendDisplayDataChangedAction=sendDisplayDataChangedAction}}`);
   filters(0).inputFilter(1);
   ModelsTableBs.doGlobalFilter(1);
   ModelsTableBs.clearAllFilters();
Index: tests/integration/components/models-table-server-paginated-test.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import {\n  moduleForComponent,\n  test\n} from 'ember-qunit';\n\nimport hbs from 'htmlbars-inline-precompile';\n\nimport {\n  generateColumns\n} from '../../helpers/f';\n\n\nmoduleForComponent('models-table-server-paginated', 'ModelsTableServerPaginated | Integration', {\n  integration: true\n});\n\ntest('should render without data', function (assert) {\n\n  let data = {};\n  this.setProperties({\n    data: data,\n    columns: generateColumns(['index'])\n  });\n\n  this.render(hbs`{{models-table-server-paginated data=data columns=columns}}`);\n  assert.ok(this.$().text());\n});\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- tests/integration/components/models-table-server-paginated-test.js	(revision cca7c13bfc4d98258e34d628a10ea298679bf05b)
+++ tests/integration/components/models-table-server-paginated-test.js	(revision )
@@ -2,26 +2,99 @@
   moduleForComponent,
   test
 } from 'ember-qunit';
-
+import wait from 'ember-test-helpers/wait';
+import {getOwner} from '@ember/application';
 import hbs from 'htmlbars-inline-precompile';
+import ModelsTableBs from '../../pages/models-table-bs';
+import {startMirage} from 'dummy/initializers/ember-cli-mirage';
 
-import {
-  generateColumns
-} from '../../helpers/f';
+import {generateColumns} from '../../helpers/f';
 
+const {navigation, filters} = ModelsTableBs;
 
 moduleForComponent('models-table-server-paginated', 'ModelsTableServerPaginated | Integration', {
-  integration: true
+  integration: true,
+  beforeEach() {
+    ModelsTableBs.setContext(this);
+    this.server = startMirage();
+    this.server.createList('user', 100);
+    this.store = getOwner(this).lookup("service:store");
+    this.set('filterQueryParameters', {
+      globalFilter: 'globalSearch',
+      sort: 'sort',
+      sortDirection: 'sortDirection',
+      page: 'page',
+      pageSize: 'pageSize'
+    });
+    this.set('columns', generateColumns(['index', 'firstName', 'lastName']));
+    return this.store.query('user', {}).then(d => this.data = d);
+  },
+  afterEach() {
+    this.server.shutdown();
+    ModelsTableBs.removeContext();
+  }
 });
 
-test('should render without data', function (assert) {
+test('#summary is updated on page change', function (assert) {
+  this.render(hbs`{{models-table-server-paginated data=data columns=columns filterQueryParameters=filterQueryParameters}}`);
+  assert.equal(ModelsTableBs.summary, 'Show 1 - 10 of 100', 'Content for 1st page (10)');
 
-  let data = {};
-  this.setProperties({
-    data: data,
-    columns: generateColumns(['index'])
-  });
+  navigation.goToNextPage();
+  return wait().then(() => assert.equal(ModelsTableBs.summary, 'Show 11 - 20 of 100', 'Content for 2nd page (10)'));
+});
 
-  this.render(hbs`{{models-table-server-paginated data=data columns=columns}}`);
-  assert.ok(this.$().text());
+test('#summary is updated on page size change', function (assert) {
+  this.render(hbs`{{models-table-server-paginated data=data columns=columns filterQueryParameters=filterQueryParameters}}`);
+  ModelsTableBs.changePageSize(25);
+  return wait().then(() => assert.equal(ModelsTableBs.summary, 'Show 1 - 25 of 100', 'Content for 1st page (25)'));
 });
+
+test('#summary is updated on global filter usage', function (assert) {
+  this.render(hbs`{{models-table-server-paginated data=data columns=columns filterQueryParameters=filterQueryParameters}}`);
+  ModelsTableBs.doGlobalFilter('100');
+  return wait().then(() => assert.equal(ModelsTableBs.summary, 'Show 1 - 1 of 1', 'Content for 1st page (1)'));
+});
+
+test('#summary is updated on column filter usage', function (assert) {
+  this.render(hbs`{{models-table-server-paginated data=data columns=columns filterQueryParameters=filterQueryParameters}}`);
+  filters(0).inputFilter('100');
+  return wait().then(() => assert.equal(ModelsTableBs.summary, 'Show 1 - 1 of 1', 'Content for 1st page (1)'));
+});
+
+test('#navigation first and prev are disabled by default', function (assert) {
+  this.render(hbs`{{models-table-server-paginated data=data columns=columns filterQueryParameters=filterQueryParameters}}`);
+  return wait().then(() => {
+    assert.ok(navigation.goToPrevPageDisabled);
+    assert.ok(navigation.goToFirstPageDisabled);
+  });
+});
+
+test('#navigation next and last are disabled when user on the last page', function (assert) {
+  this.render(hbs`{{models-table-server-paginated data=data columns=columns filterQueryParameters=filterQueryParameters}}`);
+  navigation.goToLastPage();
+  return wait().then(() => {
+    assert.ok(navigation.goToNextPageDisabled);
+    assert.ok(navigation.goToLastPageDisabled);
+  });
+});
+
+test('#navigation all buttons are enabled when user not on the last or first page', function (assert) {
+  this.render(hbs`{{models-table-server-paginated data=data columns=columns filterQueryParameters=filterQueryParameters}}`);
+  navigation.goToNextPage();
+  return wait().then(() => {
+    assert.notOk(navigation.goToNextPageDisabled);
+    assert.notOk(navigation.goToLastPageDisabled);
+    assert.notOk(navigation.goToPrevPageDisabled);
+    assert.notOk(navigation.goToFirstPageDisabled);
+  });
+});
+
+test('#content user may set custom page number to be shown initially', function (assert) {
+  this.set('currentPageNumber', 5);
+  this.render(hbs`{{models-table-server-paginated 
+    data=data
+    columns=columns
+    filterQueryParameters=filterQueryParameters
+    currentPageNumber=currentPageNumber}}`);
+  return wait().then(() => assert.equal(ModelsTableBs.summary, 'Show 41 - 50 of 100'));
+});
\ No newline at end of file
Index: addon/components/models-table-server-paginated.js
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import $ from 'jquery';\nimport {computed, setProperties, set, get} from '@ember/object';\nimport {typeOf, isBlank} from '@ember/utils';\nimport {run} from '@ember/runloop';\nimport {warn} from '@ember/debug';\nimport ModelsTable from './models-table';\nimport layout from '../templates/components/models-table';\n\nconst {extend} = $;\n\n/**\n * Table-component with pagination, sorting and filtering.\n *\n * It should be used when pagination, filtering and sorting are done on the server-side. Otherwise [models-table](Components.ModelsTable.html) should be used.\n *\n * This component extends the base models-table component. For the end user, it can be used (nearly) the same:\n *\n * ```hbs\n * {{models-table-server-paginated data=data columns=columns}}\n * ```\n *\n * Usage with block context:\n *\n * ```hbs\n * {{#models-table-server-paginated data=data columns=columns as |mt|}}\n *   {{mt.global-filter}}\n *   {{mt.columns-dropdown}}\n *   {{mt.table}}\n *   {{mt.footer}}\n * {{/models-table}}\n * ```\n *\n * ModelsTableServerPaginated yields references to the following contextual components:\n *\n * * [models-table/global-filter](Components.ModelsTableGlobalFilter.html) - global filter used for table data\n * * [models-table/columns-dropdown](Components.ModelsTableColumnsDropdown.html) - dropdown with list of options to toggle columns and column-sets visibility\n * * [models-table/table](Components.ModelsTableTable.html) - table with a data\n * * [models-table/footer](Components.ModelsTableFooter.html) - summary and pagination\n *\n * Check own docs for each component to get detailed info.\n *\n * ModelsTableServerPaginated has a lot of options you may configure, but there are two required properties called `data` and `columns`. First one contains data-query:\n *\n * ```js\n * model: function() {\n *  return this.store.query('my-model', {});\n * }\n * ```\n *\n * It will then take this query and extend it with pagination, sorting and filtering information. All other query parameters added in will remain untouched. Everything else works exactly the same - global filters, column filters etc. still use the same properties to control them. A few things to notice:\n *\n * - When using `filterWithSelect` for a column, you must use `predefinedFilterOptions`, because the automatic loading of possible filter values cannot work here.\n * - There is a new optional field `filteredBy` for columns, which works much like `sortedBy`: if set, this field will be used as query parameter, otherwise it will use the `propertyName`.\n * - Sorting will not use multipleColumnSorting, it will only sort by one column.\n * - If you set `sortedBy: false` on a column, sorting will be disabled for this column.\n *\n * There are a couple of things which can be configured to adapt to your API:\n *\n * ``` js\n * // The property on meta to load the pages count from.\n * metaPagesCountProperty: 'pagesCount',\n *\n * // The property on meta to load the total item count from.\n * metaItemsCountProperty: 'itemsCount',\n *\n * // The time to wait until new data is actually loaded.\n * // This can be tweaked to avoid making too many server requests.\n * debounceDataLoadTime: 500,\n *\n * // The query parameters to use for server side filtering / querying.\n * filterQueryParameters: {\n *   globalFilter: 'search',\n *   sort: 'sort',\n *   sortDirection: 'sortDirection',\n *   page: 'page',\n *   pageSize: 'pageSize'\n * },\n ```\n *\n * This default configuration would try to get the total page count from `model.get('meta.pagesCount')` and the total item count from `model.get('meta.itemsCount')`, and would then go on to build the following query:\n *\n * ``` js\n * columns: [\n *   {\n *     propertyName: 'name',\n *     filteredBy: 'model_name'\n *   }\n * ]\n *\n * // after searching globally for \"searchtexthere\"\n * // and in the name column for \"filterforname\",\n * // and going to page 2,\n * // the following query would be built:\n * ?page=2&pageSize=50&search=searchtexthere&sort=name&sortDirection=ASC&model_name=filterforname\n * ```\n *\n * @class ModelsTableServerPaginated\n * @namespace Components\n * @extends Components.ModelsTable\n */\nexport default ModelsTable.extend({\n\n  layout,\n\n  /**\n   * True if data is currently being loaded from the server.\n   * Can be used in the template to e.g. display a loading spinner.\n   *\n   * @type boolean\n   * @property isLoading\n   * @default false\n   */\n  isLoading: false,\n\n  /**\n   * True if last data query promise has been rejected.\n   * Can be used in the template to e.g. indicate stale data or to e.g. show error state.\n   *\n   * @type boolean\n   * @property isError\n   * @default false\n   */\n  isError: false,\n\n  /**\n   * The property on meta to load the pages count from.\n   *\n   * @type string\n   * @property metaPagesCountProperty\n   * @default 'pagesCount'\n   */\n  metaPagesCountProperty: 'pagesCount',\n  /**\n   * The property on meta to load the total item count from.\n   *\n   * @type {string}\n   * @property metaItemsCountProperty\n   * @default 'itemsCount'\n   */\n  metaItemsCountProperty: 'itemsCount',\n\n  /**\n   * The time to wait until new data is actually loaded.\n   * This can be tweaked to avoid making too many server requests.\n   *\n   * @type number\n   * @property debounceDataLoadTime\n   * @default 500\n   */\n  debounceDataLoadTime: 500,\n\n  /**\n   * The query parameters to use for server side filtering / querying.\n   *\n   * @type object\n   * @property filterQueryParameters\n   */\n  filterQueryParameters: {\n    globalFilter: 'search',\n    sort: 'sort',\n    sortDirection: 'sortDirection',\n    page: 'page',\n    pageSize: 'pageSize'\n  },\n\n  /**\n   * @property observedProperties\n   * @type string[]\n   */\n  observedProperties: ['currentPageNumber', 'sortProperties.[]', 'pageSize', 'filterString', 'processedColumns.@each.filterString'],\n\n  /**\n   * This is set during didReceiveAttr and whenever the page/filters change.\n   *\n   * @override\n   * @property filteredContent\n   * @default []\n   * @type object[]\n   */\n  filteredContent: [],\n\n  /**\n   * For server side filtering, visibleContent is same as the filtered content\n   *\n   * @override\n   * @property visibleContent\n   * @type object[]\n   */\n  visibleContent: computed.alias('arrangedContent'),\n\n  /**\n   * For server side filtering, arrangedContent is same as the filtered content\n   *\n   * @override\n   * @property arrangedContent\n   * @type object[]\n   */\n  arrangedContent: computed.alias('filteredContent'),\n\n  /**\n   * The total content length is get from the meta information.\n   * Set metaItemsCountProperty to change from which meta property this is loaded.\n   *\n   * @override\n   * @type number\n   * @property arrangedContentLength\n   */\n  arrangedContentLength: computed('filteredContent.meta', function () {\n    let itemsCountProperty = get(this, 'metaItemsCountProperty');\n    let meta = get(this, 'filteredContent.meta') || {};\n    return get(meta, itemsCountProperty) || 0;\n  }),\n\n  /**\n   * The pages count is get from the meta information.\n   * Set metaPagesCountProperty to change from which meta property this is loaded.\n   *\n   * @type number\n   * @property pagesCount\n   * @override\n   */\n  pagesCount: computed('filteredContent.meta', function () {\n    let pagesCountProperty = get(this, 'metaPagesCountProperty');\n    let meta = get(this, 'filteredContent.meta') || {};\n    return get(meta, pagesCountProperty) || 1;\n  }),\n\n  /**\n   * The index of the last item that is currently being shown.\n   *\n   * @type number\n   * @property lastIndex\n   * @override\n   */\n  lastIndex: computed('pageSize', 'currentPageNumber', 'arrangedContentLength', function () {\n    let pageMax = get(this, 'pageSize') * get(this, 'currentPageNumber');\n    let itemsCount = get(this, 'arrangedContentLength');\n    return Math.min(pageMax, itemsCount);\n  }),\n\n  /**\n   * This function actually loads the data from the server.\n   * It takes the store, modelName and query from the passed in data-object and adds page, sorting & filtering to it.\n   *\n   * @returns {undefined}\n   * @method _loadData\n   * @private\n   */\n  _loadData: function () {\n    let data = get(this, 'data');\n    let currentPageNumber = get(this, 'currentPageNumber');\n    let pageSize = get(this, 'pageSize');\n    let columns = get(this, 'processedColumns');\n    let sortProperties = get(this, 'sortProperties');\n    let filterString = get(this, 'filterString');\n\n    if (!get(data, 'query')) {\n      warn('You must use http://emberjs.com/api/data/classes/DS.Store.html#method_query for loading data');\n      return;\n    }\n    let query = extend({}, get(data, 'query'));\n    let store = get(data, 'store');\n    let modelName = get(data, 'type.modelName');\n\n    // Add pagination information\n    query[get(this, 'filterQueryParameters.page')] = currentPageNumber;\n    query[get(this, 'filterQueryParameters.pageSize')] = pageSize;\n\n    // Add sorting information\n    let sort = sortProperties && get(sortProperties, 'firstObject');\n    if (sort) {\n      let [sortBy, sortDirection] = sort.split(':');\n      query = this.sortingWrapper(query, sortBy, sortDirection.toUpperCase());\n    } else {\n      delete query[[get(this, 'filterQueryParameters.sort')]];\n      delete query[[get(this, 'filterQueryParameters.sortDirection')]];\n    }\n\n    // Add global filter\n    let globalFilter = get(this, 'filterQueryParameters.globalFilter');\n    if (filterString) {\n      query[globalFilter] = filterString;\n    } else {\n      delete query[globalFilter];\n    }\n\n    // Add per-column filter\n    if (get(this, 'useFilteringByColumns')) {\n      columns.forEach(column => {\n        let filter = get(column, 'filterString');\n        let filterTitle = this.getCustomFilterTitle(column);\n        this._setQueryFilter(query, column, filterTitle, filter);\n      });\n    }\n\n    setProperties(this, {isLoading: true, isError: false});\n\n    let promise = store.query(modelName, query);\n    promise.then(newData => setProperties(this, {isLoading: false, isError: false, filteredContent: newData}))\n      .catch(() => setProperties(this, {isLoading: false, isError: true}));\n    return promise;\n  },\n\n  /**\n   * Actually set the filter on a query.\n   * This can be overwritten for special case handling.\n   * Note that this will mutate the given query object!\n   *\n   * @param {object} query the query to mutate\n   * @param {object} column the column that is filtering\n   * @param {string} filterTitle the query param name for filtering\n   * @param {mixed} filter the actual filter value\n   * @returns {undefined}\n   * @method _setQueryFilter\n   * @private\n   */\n  _setQueryFilter(query, column, filterTitle, filter) {\n    if (!isBlank(filter)) {\n      query[filterTitle] = filter;\n    } else {\n      delete query[filterTitle];\n    }\n  },\n\n  /**\n   * Wrapper for sorting query\n   *\n   * @param {object} query parameters\n   * @param {string} sortBy\n   * @param {string} sortDirection\n   * @returns {object} query parameters\n   * @method sortingWrapper\n   */\n  sortingWrapper(query, sortBy, sortDirection) {\n    query[get(this, 'filterQueryParameters.sort')] = sortBy;\n    query[get(this, 'filterQueryParameters.sortDirection')] = sortDirection;\n\n    return query;\n  },\n\n  /**\n   * Customize filter title\n   *\n   * @method getCustomFilterTitle\n   * @param {object} column\n   * @returns {string} title\n   */\n  getCustomFilterTitle(column) {\n    return get(column, 'filteredBy') || get(column, 'propertyName');\n  },\n\n  actions: {\n\n    /**\n     * @method actions.gotoNext\n     * @returns {undefined}\n     */\n    gotoNext () {\n      if (!get(this, 'gotoForwardEnabled')) {\n        return;\n      }\n      let pagesCount = get(this, 'pagesCount');\n      let currentPageNumber = get(this, 'currentPageNumber');\n      if (pagesCount > currentPageNumber) {\n        this.incrementProperty('currentPageNumber');\n      }\n    },\n\n    /**\n     * @method actions.gotoLast\n     * @returns {undefined}\n     */\n    gotoLast () {\n      if (!get(this, 'gotoForwardEnabled')) {\n        return;\n      }\n      let pagesCount = get(this, 'pagesCount');\n      set(this, 'currentPageNumber', pagesCount);\n    },\n\n    /**\n     * @override\n     * @method actions.sort\n     * @param {ModelsTableColumn} column\n     * @returns {undefined}\n     */\n    sort (column) {\n      const sortMap = {\n        none: 'asc',\n        asc: 'desc',\n        desc: 'none'\n      };\n      let sortedBy = get(column, 'sortedBy');\n      if (typeOf(sortedBy) === 'undefined') {\n        sortedBy = get(column, 'propertyName');\n      }\n      if (!sortedBy) {\n        return;\n      }\n\n      let currentSorting = get(column, 'sorting');\n      let newSorting = sortMap[currentSorting.toLowerCase()];\n      let sortingArgs = [column, sortedBy, newSorting];\n      this._singleColumnSorting(...sortingArgs);\n      this.userInteractionObserver();\n    }\n\n  },\n\n  didReceiveAttrs() {\n    set(this, 'filteredContent', get(this, 'data'));\n  },\n\n  _addPropertyObserver() {\n    run.debounce(this, this._loadData, get(this, 'debounceDataLoadTime'));\n  },\n\n  willInsertElement() {\n    this._super(...arguments);\n\n    let observedProperties = get(this, 'observedProperties');\n    observedProperties.forEach(propertyName => this.addObserver(propertyName, this._addPropertyObserver));\n  },\n\n  willDestroyElement() {\n    this._super(...arguments);\n\n    let observedProperties = get(this, 'observedProperties');\n    observedProperties.forEach(propertyName => this.removeObserver(propertyName));\n  }\n});\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- addon/components/models-table-server-paginated.js	(revision cca7c13bfc4d98258e34d628a10ea298679bf05b)
+++ addon/components/models-table-server-paginated.js	(revision )
@@ -233,7 +233,7 @@
    * @override
    */
   lastIndex: computed('pageSize', 'currentPageNumber', 'arrangedContentLength', function () {
-    let pageMax = get(this, 'pageSize') * get(this, 'currentPageNumber');
+    let pageMax = parseInt(get(this, 'pageSize'), 10) * get(this, 'currentPageNumber');
     let itemsCount = get(this, 'arrangedContentLength');
     return Math.min(pageMax, itemsCount);
   }),
